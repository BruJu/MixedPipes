{"mappings":"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","sources":["<anon>","src/app.ts","src/maze-generator.ts","src/base/dir.ts","src/base/grid-component.ts","src/grid-solver.ts","src/base/abstract-grid.ts","src/solver/component.ts"],"sourcesContent":["/** Possible directions */ const $461fef29bc99ab5c$export$e9e050f4e0d75ba8 = [\n    \"north\",\n    \"east\",\n    \"west\",\n    \"south\"\n];\nfunction $461fef29bc99ab5c$export$5b8cb9ace9acd75e(dir) {\n    switch(dir){\n        case \"north\":\n            return \"south\";\n        case \"south\":\n            return \"north\";\n        case \"west\":\n            return \"east\";\n        case \"east\":\n            return \"west\";\n        default:\n            throw Error(\"Unknown dir\");\n    }\n}\n\n\nfunction $4eca0d64d93ccd58$export$df9acae4caeab4be(self) {\n    return `${self.y},${self.x}`;\n}\nfunction $4eca0d64d93ccd58$export$a96947902a32785e(self, dir, gridConf) {\n    const copy = Object.assign({}, self);\n    switch(dir){\n        case \"north\":\n            if (copy.y !== 0) --copy.y;\n            else {\n                if (gridConf.brokenWalls) copy.y = gridConf.height - 1;\n                else return null;\n            }\n            break;\n        case \"south\":\n            if (copy.y !== gridConf.height - 1) ++copy.y;\n            else {\n                if (gridConf.brokenWalls) copy.y = 0;\n                else return null;\n            }\n            break;\n        case \"east\":\n            if (copy.x !== gridConf.width - 1) ++copy.x;\n            else {\n                if (gridConf.brokenWalls) copy.x = 0;\n                else return null;\n            }\n            break;\n        case \"west\":\n            if (copy.x !== 0) --copy.x;\n            else {\n                if (gridConf.brokenWalls) copy.x = gridConf.width - 1;\n                else return null;\n            }\n            break;\n    }\n    return copy;\n}\nfunction $4eca0d64d93ccd58$export$9189e1451ddd7d48(slot) {\n    return (slot.north ? 1 : 0) + (slot.south ? 1 : 0) + (slot.east ? 1 : 0) + (slot.west ? 1 : 0);\n}\n\n\n/**\r\n * A mapping of slots to their group\r\n * \r\n * Uses the Union-Find algorithm:\r\n * https://en.wikipedia.org/wiki/Disjoint-set_data_structure\r\n */ class $4101c19663cb0e03$var$UnionFind {\n    /** Slot index on a 1D scale to group id */ #slotToGroup;\n    /** Number of slots per line, used to compute the index on a 1D scale */ #width;\n    constructor(width, height){\n        this.#width = width;\n        this.#slotToGroup = new Map();\n        // makeSet\n        for(let i = 0; i != width * height; ++i)this.#slotToGroup.set(i, i);\n    }\n    /** Return the root of the tree in which the given slot is */ find(slot) {\n        let expected = slot.x + slot.y * this.#width;\n        while(true){\n            let realGroupId = this.#slotToGroup.get(expected);\n            if (realGroupId === expected) return expected;\n            expected = realGroupId;\n        }\n    }\n    /** Merge the trees where slot1 and slot2 are */ union(slot1, slot2) {\n        this.#slotToGroup.set(this.find(slot1), this.find(slot2));\n    }\n}\n/**\r\n * Builds the list of place where a wall can be broken. Two lists are returned:\r\n * one for horizontal walls (east to west) and one for vertical walls\r\n * (north to south).\r\n * @param gridConf The grid configuration\r\n * @returns The list of slots where there are breakable walls\r\n */ function $4101c19663cb0e03$var$initWalls(gridConf) {\n    const h = [];\n    const v = [];\n    const notBroken = gridConf.brokenWalls ? 0 : 1;\n    for(let x = 0; x != gridConf.width; ++x)for(let y = 0; y != gridConf.height; ++y){\n        if (x != gridConf.width - notBroken) h.push({\n            x: x,\n            y: y\n        });\n        if (y != gridConf.height - notBroken) v.push({\n            x: x,\n            y: y\n        });\n    }\n    return {\n        h: h,\n        v: v\n    };\n}\n/**\r\n * Builds the list of walls to open\r\n * @param gridConf The grid configuration\r\n * @returns The list of walls to open\r\n */ function $4101c19663cb0e03$var$buildOpenWalls(gridConf) {\n    const groups = new $4101c19663cb0e03$var$UnionFind(gridConf.width, gridConf.height);\n    const { h: h, v: v } = $4101c19663cb0e03$var$initWalls(gridConf);\n    let numberOfDiffGroups = gridConf.width * gridConf.height;\n    let res = [];\n    let openedWalls = new Map();\n    const breakable = (slot)=>{\n        let cnt = openedWalls.get(slot.x + slot.y * gridConf.width);\n        if (cnt === undefined) return true;\n        if (cnt >= 3) return false;\n        return true;\n    };\n    while(numberOfDiffGroups > 1){\n        const breakHorizontal = Math.random() >= 0.5;\n        const dir = breakHorizontal ? \"east\" : \"south\";\n        const wallsToBreak = breakHorizontal ? h : v;\n        if (wallsToBreak.length === 0) continue;\n        const randomIndex = Math.floor(Math.random() * wallsToBreak.length);\n        const slot1 = wallsToBreak[randomIndex];\n        const slot2 = (0, $4eca0d64d93ccd58$export$a96947902a32785e)(slot1, dir, gridConf);\n        wallsToBreak.splice(randomIndex, 1);\n        if (!breakable(slot1) || !breakable(slot2)) continue;\n        if (groups.find(slot1) !== groups.find(slot2)) {\n            res.push({\n                x: slot1.x,\n                y: slot1.y,\n                to: dir\n            });\n            groups.union(slot1, slot2);\n            --numberOfDiffGroups;\n            const g1 = slot1.x + slot1.y * gridConf.width;\n            openedWalls.set(g1, (openedWalls.get(g1) || 0) + 1);\n            const g2 = slot2.x + slot2.y * gridConf.width;\n            openedWalls.set(g2, (openedWalls.get(g2) || 0) + 1);\n        }\n    }\n    return res;\n}\n/** Builds an initial grid with no pipe */ function $4101c19663cb0e03$var$initializeMaze(gridConf) {\n    const theMaze = [];\n    for(let row = 0; row != gridConf.height; ++row){\n        const theRow = [];\n        for(let col = 0; col != gridConf.width; ++col)theRow.push({\n            north: false,\n            east: false,\n            west: false,\n            south: false\n        });\n        theMaze.push(theRow);\n    }\n    return theMaze;\n}\nfunction $4101c19663cb0e03$export$2e2bcd8739ae039(gridConf) {\n    const maze = $4101c19663cb0e03$var$initializeMaze(gridConf);\n    for (const { x: x, y: y, to: to } of $4101c19663cb0e03$var$buildOpenWalls(gridConf)){\n        const origin = {\n            x: x,\n            y: y\n        };\n        const neighbour = (0, $4eca0d64d93ccd58$export$a96947902a32785e)(origin, to, gridConf);\n        maze[origin.y][origin.x][to] = true;\n        maze[neighbour.y][neighbour.x][(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(to)] = true;\n    }\n    return maze;\n}\n\n\n\n\nclass $6a83c7ebd8a22ba4$export$ef2184bd89960b14 {\n    /**\r\n   * Moves from the given point to the given direction\r\n   * @param point The starting point\r\n   * @param dir The direction\r\n   * @returns The destination, or null if it would lead out of bound\r\n   */ #move(point, dir) {\n        if (dir === \"north\") {\n            if (point.y !== 0) return {\n                x: point.x,\n                y: point.y - 1\n            };\n            else {\n                if (!this.brokenWalls) return null;\n                return {\n                    x: point.x,\n                    y: this.height - 1\n                };\n            }\n        } else if (dir === \"south\") {\n            if (point.y !== this.height - 1) return {\n                x: point.x,\n                y: point.y + 1\n            };\n            else {\n                if (!this.brokenWalls) return null;\n                return {\n                    x: point.x,\n                    y: 0\n                };\n            }\n        } else if (dir === \"west\") {\n            if (point.x !== 0) return {\n                x: point.x - 1,\n                y: point.y\n            };\n            else {\n                if (!this.brokenWalls) return null;\n                return {\n                    x: this.width - 1,\n                    y: point.y\n                };\n            }\n        } else if (dir === \"east\") {\n            if (point.x !== this.width - 1) return {\n                x: point.x + 1,\n                y: point.y\n            };\n            else {\n                if (!this.brokenWalls) return null;\n                return {\n                    x: 0,\n                    y: point.y\n                };\n            }\n        } else return null;\n    }\n    /**\r\n   * Returns the four neighbours of the point. If the neighbour is a wall,\r\n   * null is returned instead of a slot and an out-of-bound neighbour point.\r\n   * @param point The point\r\n   * @returns The list of neighbours, both slots and out-of-bound.\r\n   */ getNeighboursOf(point) {\n        return (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8).map((dir)=>{\n            const target = this.#move(point, dir);\n            if (target === null) return {\n                other: null,\n                point: null,\n                dir: dir\n            };\n            else return {\n                other: this.get(target),\n                point: target,\n                dir: dir\n            };\n        });\n    }\n    /**\r\n   * Returns the list of slot neighbours of the given point\r\n   * @param point The point\r\n   * @returns The list of slot neighbours\r\n   */ getNeighbourSlotsOf(point) {\n        return this.getNeighboursOf(point).filter((c)=>c.other !== null);\n    }\n}\n\n\n\n\n\nvar $cfaaa711720d035c$export$4f6ff81f13e75033;\n(function(DirStatus) {\n    DirStatus[DirStatus[\"Maybe\"] = 0] = \"Maybe\";\n    DirStatus[DirStatus[\"Yes\"] = 1] = \"Yes\";\n    DirStatus[DirStatus[\"No\"] = 2] = \"No\";\n})($cfaaa711720d035c$export$4f6ff81f13e75033 || ($cfaaa711720d035c$export$4f6ff81f13e75033 = {}));\nfunction $cfaaa711720d035c$export$235fd46f8105e076(status) {\n    if (status === $cfaaa711720d035c$export$4f6ff81f13e75033.Yes) return $cfaaa711720d035c$export$4f6ff81f13e75033.No;\n    if (status === $cfaaa711720d035c$export$4f6ff81f13e75033.No) return $cfaaa711720d035c$export$4f6ff81f13e75033.Yes;\n    return status;\n}\nfunction $cfaaa711720d035c$export$70bdf160882970fb(slot) {\n    if (slot.blocked) return slot;\n    else {\n        const numberOfDirections = (0, $4eca0d64d93ccd58$export$9189e1451ddd7d48)(slot);\n        if (numberOfDirections === 4 || numberOfDirections === 0) return slot;\n        else return {\n            south: $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe,\n            north: $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe,\n            west: $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe,\n            east: $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe,\n            form: $cfaaa711720d035c$export$92abc197554724f7(slot)\n        };\n    }\n}\nfunction $cfaaa711720d035c$export$6ab1d8ea5a7dd022(slot) {\n    const yes = $cfaaa711720d035c$export$231ac6a5472d9be8(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Yes);\n    const no = $cfaaa711720d035c$export$231ac6a5472d9be8(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.No);\n    if (slot.form === \"T\") {\n        if (yes === 4 || no >= 2) return \"bad\";\n        if (yes === 3) return $cfaaa711720d035c$var$ResearchSlot_finalize(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.No);\n        if (no === 1) return $cfaaa711720d035c$var$ResearchSlot_finalize(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Yes);\n    } else if (slot.form === \"i\") {\n        if (yes > 1 || no > 3) return \"bad\";\n        if (yes === 1) return $cfaaa711720d035c$var$ResearchSlot_finalize(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.No);\n        if (no === 3) return $cfaaa711720d035c$var$ResearchSlot_finalize(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Yes);\n    } else if (slot.form === \"I\") {\n        if (yes > 2 || no > 2) return \"bad\";\n        for (const dir of (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8)){\n            if (slot[dir] === $cfaaa711720d035c$export$4f6ff81f13e75033.Yes && slot[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)] === $cfaaa711720d035c$export$4f6ff81f13e75033.No) return \"bad\";\n        }\n        if (yes > 0 || no > 0) {\n            for (const dir of (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8))if (slot[dir] !== $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe) {\n                for (const d of (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8))slot[d] = d === dir || d === (0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir) ? slot[dir] : $cfaaa711720d035c$export$235fd46f8105e076(slot[dir]);\n                return $cfaaa711720d035c$var$ResearchSlot_finalize(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Yes);\n            }\n        }\n    } else if (slot.form === \"L\") {\n        if (yes > 2 || no > 2) return \"bad\";\n        for (const dir of (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8))if (slot[dir] !== $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe) {\n            if (slot[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)] === slot[dir]) return \"bad\";\n        }\n        const maybeBefore = $cfaaa711720d035c$export$231ac6a5472d9be8(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe);\n        for (const dir of (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8))if (slot[dir] !== $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe) slot[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)] = $cfaaa711720d035c$export$235fd46f8105e076(slot[dir]);\n        const maybeAfter = $cfaaa711720d035c$export$231ac6a5472d9be8(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe);\n        if (maybeAfter === 0) return $cfaaa711720d035c$var$ResearchSlot_finalize(slot, $cfaaa711720d035c$export$4f6ff81f13e75033.Yes);\n        if (maybeBefore !== maybeAfter) return \"new_info\";\n    }\n    return undefined;\n}\nfunction $cfaaa711720d035c$var$ResearchSlot_finalize(slot, maybeBecomes) {\n    const pass = (status)=>(status === $cfaaa711720d035c$export$4f6ff81f13e75033.Maybe ? maybeBecomes : status) === $cfaaa711720d035c$export$4f6ff81f13e75033.Yes;\n    return {\n        north: pass(slot.north),\n        south: pass(slot.south),\n        east: pass(slot.east),\n        west: pass(slot.west)\n    };\n}\nfunction $cfaaa711720d035c$export$9c3cbfd253bd2762(slot) {\n    if (\"form\" in slot) return Object.assign({}, slot);\n    else return slot;\n}\nfunction $cfaaa711720d035c$export$231ac6a5472d9be8(slot, status) {\n    let cnt = 0;\n    if (slot.north === status) ++cnt;\n    if (slot.south === status) ++cnt;\n    if (slot.east === status) ++cnt;\n    if (slot.west === status) ++cnt;\n    return cnt;\n}\nfunction $cfaaa711720d035c$export$92abc197554724f7(slot) {\n    const numberOfDirections = (0, $4eca0d64d93ccd58$export$9189e1451ddd7d48)(slot);\n    switch(numberOfDirections){\n        case 1:\n            return \"i\";\n        case 3:\n            return \"T\";\n        case 2:\n            return slot.south === slot.north ? \"I\" : \"L\";\n        default:\n            throw Error(\"Fixed form slot\");\n    }\n}\n\n\nclass $24c03f35ab1abff0$export$2bacf20dee8043b5 extends (0, $6a83c7ebd8a22ba4$export$ef2184bd89960b14) {\n    get width() {\n        return this.ruleset.width;\n    }\n    get height() {\n        return this.ruleset.height;\n    }\n    get brokenWalls() {\n        return this.ruleset.brokenWalls;\n    }\n    get(point) {\n        return this._slots[point.y][point.x];\n    }\n    constructor(theSlots, original){\n        super();\n        this._slots = theSlots;\n        this.ruleset = original;\n    }\n    static fromIGrid(grid) {\n        let theSlots = [];\n        for(let y = 0; y !== grid.height; ++y){\n            let row = [];\n            for(let x = 0; x !== grid.width; ++x)row.push((0, $cfaaa711720d035c$export$70bdf160882970fb)(grid.get({\n                x: x,\n                y: y\n            })));\n            theSlots.push(row);\n        }\n        return new $24c03f35ab1abff0$export$2bacf20dee8043b5(theSlots, grid);\n    }\n    clone() {\n        let theSlots = [];\n        for(let y = 0; y !== this.height; ++y){\n            let row = [];\n            for(let x = 0; x !== this.width; ++x)row.push((0, $cfaaa711720d035c$export$9c3cbfd253bd2762)(this._slots[y][x]));\n            theSlots.push(row);\n        }\n        return new $24c03f35ab1abff0$export$2bacf20dee8043b5(theSlots, this);\n    }\n    solveSomeSlots(newSolutions) {\n        let unstable = false;\n        for(let row = 0; row !== this.height; ++row)for(let col = 0; col !== this.width; ++col){\n            const notStable = this.solveAt({\n                x: col,\n                y: row\n            }, newSolutions);\n            if (notStable === \"bad\") return \"bad\";\n            unstable ||= notStable;\n        }\n        return unstable;\n    }\n    solveAt(point, newSolutions) {\n        const slot = this._slots[point.y][point.x];\n        if (!(\"form\" in slot)) return false;\n        const solution = (0, $cfaaa711720d035c$export$6ab1d8ea5a7dd022)(slot);\n        if (solution === undefined) return false;\n        if (solution === \"bad\") return \"bad\";\n        if (solution !== \"new_info\") {\n            this._slots[point.y][point.x] = solution;\n            newSolutions.push(Object.assign(point, solution));\n        }\n        return true;\n    }\n    removeInvalidHypothesises(solved) {\n        let unstable = false;\n        for(let y = 0; y != this.height; ++y)for(let x = 0; x != this.width; ++x){\n            const slot = this._slots[y][x];\n            if (!(\"form\" in slot)) continue;\n            this.getNeighbourSlotsOf({\n                x: x,\n                y: y\n            }).forEach(({ other: other, dir: dir })=>{\n                const r = $24c03f35ab1abff0$var$considerOther(slot, other, dir);\n                unstable ||= r;\n            });\n            let solveAtRes = this.solveAt({\n                x: x,\n                y: y\n            }, solved);\n            if (solveAtRes === \"bad\") return \"bad\";\n            unstable ||= solveAtRes;\n        }\n        return unstable;\n    }\n    initialDeductions() {\n        const isAni = (slot)=>{\n            if (\"form\" in slot) return slot.form === \"i\";\n            const out = (0, $4eca0d64d93ccd58$export$9189e1451ddd7d48)(slot);\n            return out === 1;\n        };\n        const moreThanTwois = (()=>{\n            let cnt = 0;\n            for(let y = 0; y != this.height; ++y)for(let x = 0; x != this.width; ++x){\n                const slot = this._slots[y][x];\n                if (isAni(slot)) {\n                    if (cnt < 2) ++cnt;\n                    else return true;\n                }\n            }\n            return false;\n        })();\n        for(let y = 0; y != this.height; ++y)for(let x = 0; x != this.width; ++x){\n            const slot = this._slots[y][x];\n            if (!(\"form\" in slot)) continue;\n            this.getNeighboursOf({\n                x: x,\n                y: y\n            }).forEach(({ other: other, dir: dir })=>{\n                if (other === null) slot[dir] = (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No;\n                else if (isAni(slot) && isAni(other)) {\n                    slot[dir] = moreThanTwois ? (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No : (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes;\n                    if (\"form\" in other) other[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)] = moreThanTwois ? (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No : (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes;\n                }\n            });\n        }\n    }\n    explorePossibilitiesOfanI() {\n        let listOfIs = [];\n        const others = [];\n        for(let y = 0; y !== this.height; ++y)for(let x = 0; x !== this.width; ++x){\n            const slot = this._slots[y][x];\n            if (\"form\" in slot) {\n                if (slot.form === \"I\") listOfIs.push({\n                    x: x,\n                    y: y\n                });\n                else others.push({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n        if (listOfIs.length === 0) {\n            listOfIs = others;\n            if (listOfIs.length === 0) return null;\n        }\n        const point = listOfIs[Math.floor(Math.random() * listOfIs.length)];\n        const current = this._slots[point.y][point.x];\n        function compatible(slot, current) {\n            for (const dir of (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8)){\n                if (current[dir] === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes && slot[dir] !== true) return false;\n                if (current[dir] === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No && slot[dir] !== false) return false;\n            }\n            return true;\n        }\n        for (const slot of $24c03f35ab1abff0$var$possibleSlots(current.form).filter((slot)=>compatible(slot, current))){\n            const clone = this.clone();\n            clone._slots[point.y][point.x] = slot;\n            if (clone.getCompletitionState() === $24c03f35ab1abff0$export$95796b681493d318.Invalid) continue;\n            const solution = clone.trySolve();\n            if (solution !== null) return [\n                Object.assign(point, slot),\n                ...solution\n            ];\n        }\n        return null;\n    }\n    trySolve() {\n        let solution = [];\n        this.initialDeductions();\n        while(true){\n            const r = this.removeInvalidHypothesises(solution);\n            if (r === \"bad\") return null;\n            if (r === false) break;\n        }\n        const gridState = this.getCompletitionState();\n        if (gridState === $24c03f35ab1abff0$export$95796b681493d318.Invalid) return null;\n        else if (gridState === $24c03f35ab1abff0$export$95796b681493d318.IncompleteValid) {\n            const hop = this.explorePossibilitiesOfanI();\n            if (!hop) return null;\n            return [\n                ...solution,\n                ...hop\n            ];\n        } else return solution;\n    }\n    getCompletitionState() {\n        // Search for a loop\n        let map = new Map();\n        for(let iRow = 0; iRow !== this.height; ++iRow)for(let iCol = 0; iCol !== this.width; ++iCol)map.set((0, $4eca0d64d93ccd58$export$df9acae4caeab4be)({\n            x: iCol,\n            y: iRow\n        }), (0, $4eca0d64d93ccd58$export$df9acae4caeab4be)({\n            x: iCol,\n            y: iRow\n        }));\n        const rootOf = (point)=>{\n            let x = map.get((0, $4eca0d64d93ccd58$export$df9acae4caeab4be)(point));\n            while(x !== map.get(x))x = map.get(x);\n            return x;\n        };\n        const rootOfStr = (point)=>{\n            let x = map.get(point);\n            while(x !== map.get(x))x = map.get(x);\n            return x;\n        };\n        // Ok\n        function compatible(lhs, rhs) {\n            if (lhs === true || lhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes) return rhs === true || rhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes || rhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe;\n            else if (lhs === false || lhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No) return rhs === false || rhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No || rhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe;\n            else return true;\n        }\n        function connected(lhs, rhs) {\n            return (lhs === true || lhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes || lhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe) && (rhs === true || rhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes || rhs === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe);\n        }\n        let isIncomplete = false;\n        for(let iRow = 0; iRow !== this.height; ++iRow)for(let iCol = 0; iCol !== this.width; ++iCol){\n            const slot = this._slots[iRow][iCol];\n            if (\"form\" in slot) isIncomplete = true;\n            let invalid = false;\n            this.getNeighboursOf({\n                x: iCol,\n                y: iRow\n            }).forEach(({ other: other, point: point, dir: dir })=>{\n                if (other === null) {\n                    if (slot[dir] === true || slot[dir] === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes) invalid = true;\n                } else {\n                    if (!compatible(slot[dir], other[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)])) invalid = true;\n                    if (connected(slot[dir], other[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)])) map.set(rootOf({\n                        x: iCol,\n                        y: iRow\n                    }), rootOf(point));\n                }\n            });\n            if (invalid) return $24c03f35ab1abff0$export$95796b681493d318.Invalid;\n        }\n        const group0 = rootOf({\n            x: 0,\n            y: 0\n        });\n        for (const val of map.keys()){\n            if (group0 !== rootOfStr(val)) return $24c03f35ab1abff0$export$95796b681493d318.Invalid;\n        }\n        return isIncomplete ? $24c03f35ab1abff0$export$95796b681493d318.IncompleteValid : $24c03f35ab1abff0$export$95796b681493d318.CompleteValid;\n    }\n}\nvar $24c03f35ab1abff0$export$95796b681493d318;\n(function(CompletitionStatus) {\n    CompletitionStatus[CompletitionStatus[\"IncompleteValid\"] = 0] = \"IncompleteValid\";\n    CompletitionStatus[CompletitionStatus[\"CompleteValid\"] = 1] = \"CompleteValid\";\n    CompletitionStatus[CompletitionStatus[\"Invalid\"] = 2] = \"Invalid\";\n})($24c03f35ab1abff0$export$95796b681493d318 || ($24c03f35ab1abff0$export$95796b681493d318 = {}));\nfunction $24c03f35ab1abff0$var$possibleSlots(form) {\n    if (form === \"i\") return [\n        {\n            north: true,\n            east: false,\n            south: false,\n            west: false\n        },\n        {\n            north: false,\n            east: true,\n            south: false,\n            west: false\n        },\n        {\n            north: false,\n            east: false,\n            south: true,\n            west: false\n        },\n        {\n            north: false,\n            east: false,\n            south: false,\n            west: true\n        }\n    ];\n    else if (form === \"I\") return [\n        {\n            north: true,\n            east: false,\n            south: true,\n            west: false\n        },\n        {\n            north: false,\n            east: true,\n            south: false,\n            west: true\n        }\n    ];\n    else if (form === \"L\") return [\n        {\n            north: true,\n            east: true,\n            south: false,\n            west: false\n        },\n        {\n            north: false,\n            east: true,\n            south: true,\n            west: false\n        },\n        {\n            north: false,\n            east: false,\n            south: true,\n            west: true\n        },\n        {\n            north: true,\n            east: false,\n            south: false,\n            west: true\n        }\n    ];\n    else return [\n        {\n            north: true,\n            east: true,\n            south: true,\n            west: false\n        },\n        {\n            north: false,\n            east: true,\n            south: true,\n            west: true\n        },\n        {\n            north: true,\n            east: false,\n            south: true,\n            west: true\n        },\n        {\n            north: true,\n            east: true,\n            south: false,\n            west: true\n        }\n    ];\n}\nfunction $24c03f35ab1abff0$export$2e2bcd8739ae039(grid) {\n    const solved = [];\n    const solvationGrid = $24c03f35ab1abff0$export$2bacf20dee8043b5.fromIGrid(grid);\n    let r = solvationGrid.trySolve();\n    return r || [];\n}\nfunction $24c03f35ab1abff0$var$considerOther(slot, other, myDir) {\n    const otherDir = (0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(myDir);\n    if (!(\"form\" in other)) {\n        const expect = other[otherDir] ? (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Yes : (0, $cfaaa711720d035c$export$4f6ff81f13e75033).No;\n        if (slot[myDir] === expect) return false;\n        slot[myDir] = expect;\n        return true;\n    }\n    if (other[otherDir] === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe) {\n        if (slot[myDir] !== (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe) {\n            other[otherDir] = slot[myDir];\n            return true;\n        }\n    } else if (slot[myDir] === (0, $cfaaa711720d035c$export$4f6ff81f13e75033).Maybe) {\n        slot[myDir] = other[otherDir];\n        return true;\n    }\n    return false;\n} /*\r\nfunction isAni(slot: InstanciatedSlot | ResearchSlot | null) {\r\n  if (slot === null) return false;\r\n  if ('form' in slot) return slot.form === 'i';\r\n  return countNbOfOutput(slot) === 1;\r\n}\r\n\r\nfunction solvePathways(grid: ResearchGrid) {\r\n  for (let y = 0; y != grid.height; ++y) {\r\n    for (let x = 0; x != grid.width; ++x) {\r\n      const slot = grid.grid[y][x];\r\n\r\n      if ('form' in slot && slot.form === 'I') {\r\n        if (isAni(grid.get({ x, y }, 'east')) && isAni(grid.get({ x, y }, 'west'))) {\r\n          slot.east = DirStatus.No;\r\n          slot.west = DirStatus.No;\r\n        }\r\n\r\n        if (isAni(grid.get({ x, y }, 'south')) && isAni(grid.get({ x, y }, 'north'))) {\r\n          slot.south = DirStatus.No;\r\n          slot.north = DirStatus.No;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n*/ \n\n\n\n\nconst $f43313d21d3fd8e2$var$SLOT_SIZE = 100;\nconst $f43313d21d3fd8e2$var$LINE_SIZE = 20;\nvar $f43313d21d3fd8e2$var$LockParadigm;\n(function(LockParadigm) {\n    LockParadigm[LockParadigm[\"LockedOk\"] = 0] = \"LockedOk\";\n    LockParadigm[LockParadigm[\"LockedWithConflict\"] = 1] = \"LockedWithConflict\";\n    LockParadigm[LockParadigm[\"NotLocked\"] = 2] = \"NotLocked\";\n})($f43313d21d3fd8e2$var$LockParadigm || ($f43313d21d3fd8e2$var$LockParadigm = {}));\nvar $f43313d21d3fd8e2$var$Playstyle;\n(function(Playstyle) {\n    Playstyle[Playstyle[\"Free\"] = 0] = \"Free\";\n    Playstyle[Playstyle[\"Restrained\"] = 1] = \"Restrained\";\n    Playstyle[Playstyle[\"AutoLock\"] = 2] = \"AutoLock\";\n})($f43313d21d3fd8e2$var$Playstyle || ($f43313d21d3fd8e2$var$Playstyle = {}));\nfunction $f43313d21d3fd8e2$var$lockParadigmToStyle(lockedParadigm) {\n    switch(lockedParadigm){\n        case $f43313d21d3fd8e2$var$LockParadigm.LockedOk:\n            return \"darkgrey\";\n        case $f43313d21d3fd8e2$var$LockParadigm.LockedWithConflict:\n            return \"red\";\n        case $f43313d21d3fd8e2$var$LockParadigm.NotLocked:\n            return \"lightgrey\";\n        default:\n            return \"green\";\n    }\n}\nfunction $f43313d21d3fd8e2$var$getCurrentPlaystyle() {\n    const select = document.getElementById(\"qol_spin\");\n    if (select.value === \"autolock\") return $f43313d21d3fd8e2$var$Playstyle.AutoLock;\n    else if (select.value === \"restrained\") return $f43313d21d3fd8e2$var$Playstyle.Restrained;\n    else return $f43313d21d3fd8e2$var$Playstyle.Free;\n}\nfunction $f43313d21d3fd8e2$var$rotateSlot(slot, x, y, maze) {\n    if (slot.blocked) return;\n    const slotPoint = {\n        x: x,\n        y: y\n    };\n    const playstyle = $f43313d21d3fd8e2$var$getCurrentPlaystyle();\n    if (playstyle === $f43313d21d3fd8e2$var$Playstyle.AutoLock || playstyle === $f43313d21d3fd8e2$var$Playstyle.Restrained) {\n        let goodFits = [\n            false,\n            false,\n            false,\n            false\n        ];\n        for(let i = 0; i != 4; ++i){\n            slot.rotate();\n            goodFits[i] = maze.fitsWithNearbyBlocked(slotPoint);\n        }\n        let nbOfGoodFits = goodFits.filter((x)=>x).length;\n        if (slot.isABar()) nbOfGoodFits /= 2;\n        if (playstyle === $f43313d21d3fd8e2$var$Playstyle.AutoLock && nbOfGoodFits === 1) {\n            while(!maze.fitsWithNearbyBlocked(slotPoint))slot.rotate();\n            slot.blocked = true;\n        } else if ((playstyle === $f43313d21d3fd8e2$var$Playstyle.Restrained || playstyle === $f43313d21d3fd8e2$var$Playstyle.AutoLock) && nbOfGoodFits > 0) {\n            slot.rotate();\n            while(!maze.fitsWithNearbyBlocked(slotPoint))slot.rotate();\n        } else slot.rotate();\n    } else slot.rotate();\n}\nclass $f43313d21d3fd8e2$var$RealSlot {\n    countPaths() {\n        return (0, $461fef29bc99ab5c$export$e9e050f4e0d75ba8).map((dir)=>this[dir]).filter((x)=>x).length;\n    }\n    isABar() {\n        return this.north == this.south && this.west == this.east && this.north !== this.west;\n    }\n    draw(context, x, y, width, height, pipeStyle, lockParadigm, drawOnePath) {\n        context.fillStyle = \"black\";\n        context.fillRect(x, y, width, height);\n        context.fillStyle = $f43313d21d3fd8e2$var$lockParadigmToStyle(lockParadigm);\n        context.fillRect(x + 1, y + 1, width - 2, height - 2);\n        context.fillStyle = pipeStyle;\n        if (this.north) context.fillRect(x + width / 2 - $f43313d21d3fd8e2$var$LINE_SIZE / 2, y, $f43313d21d3fd8e2$var$LINE_SIZE, height / 2);\n        if (this.south) context.fillRect(x + width / 2 - $f43313d21d3fd8e2$var$LINE_SIZE / 2, y + height / 2, $f43313d21d3fd8e2$var$LINE_SIZE, height / 2);\n        if (this.west) context.fillRect(x, y + height / 2 - $f43313d21d3fd8e2$var$LINE_SIZE / 2, width / 2, $f43313d21d3fd8e2$var$LINE_SIZE);\n        if (this.east) context.fillRect(x + width / 2, y + height / 2 - $f43313d21d3fd8e2$var$LINE_SIZE / 2, width / 2, $f43313d21d3fd8e2$var$LINE_SIZE);\n        if (this.countPaths() === 1) {\n            if (drawOnePath) context.fillStyle = \"blue\";\n            context.fillRect(x + width / 2 - $f43313d21d3fd8e2$var$LINE_SIZE / 2, y + height / 2 - $f43313d21d3fd8e2$var$LINE_SIZE / 2, $f43313d21d3fd8e2$var$LINE_SIZE, $f43313d21d3fd8e2$var$LINE_SIZE);\n        }\n    }\n    rotate() {\n        if (this.blocked) return;\n        let temp = this.north;\n        this.north = this.east;\n        this.east = this.south;\n        this.south = this.west;\n        this.west = temp;\n    }\n    constructor(){\n        this.north = false;\n        this.east = false;\n        this.west = false;\n        this.south = false;\n        this.blocked = false;\n    }\n}\nclass $f43313d21d3fd8e2$var$PlayerMaze extends (0, $6a83c7ebd8a22ba4$export$ef2184bd89960b14) {\n    constructor(width, height, brokenWalls = false){\n        super();\n        this.blackPipes = true;\n        this.width = width;\n        this.height = height;\n        this.brokenWalls = brokenWalls;\n        // ==== 1) Initial grid\n        const configuration = (0, $4101c19663cb0e03$export$2e2bcd8739ae039)({\n            width: width,\n            height: height,\n            brokenWalls: brokenWalls\n        });\n        this.grid = [];\n        for(let y = 0; y != height; ++y){\n            let row = [];\n            for(let x = 0; x != width; ++x){\n                const config = configuration[y][x];\n                const slot = new $f43313d21d3fd8e2$var$RealSlot();\n                Object.assign(slot, config);\n                for(let rotate = Math.floor(Math.random() * 4); rotate >= 0; --rotate)slot.rotate();\n                row.push(slot);\n            }\n            this.grid.push(row);\n        }\n    }\n    get(point) {\n        return this.grid[point.y][point.x];\n    }\n    invertColorDisplay() {\n        this.blackPipes = !this.blackPipes;\n    }\n    draw(canvas) {\n        let getPipeColor;\n        if (this.blackPipes) {\n            if (this.checkWin()) getPipeColor = ()=>\"blue\";\n            else getPipeColor = ()=>\"black\";\n        } else {\n            const mapping = $f43313d21d3fd8e2$var$computeNetworks(this);\n            getPipeColor = (x, y)=>mapping.get(x + y * this.width) || \"black\";\n        }\n        const ctx = canvas.getContext(\"2d\");\n        const extra = this.brokenWalls ? $f43313d21d3fd8e2$var$SLOT_SIZE / 2 : 0;\n        ctx.fillStyle = \"red\";\n        ctx.fillRect(0, 0, this.width * $f43313d21d3fd8e2$var$SLOT_SIZE + extra * 2, this.height * $f43313d21d3fd8e2$var$SLOT_SIZE + extra * 2);\n        for(let y = 0; y != this.height; ++y)for(let x = 0; x != this.width; ++x){\n            const color = getPipeColor(x, y);\n            const slot = this.grid[y][x];\n            const lp = this._lockParadigmOf(slot, x, y);\n            slot.draw(ctx, x * $f43313d21d3fd8e2$var$SLOT_SIZE + extra, y * $f43313d21d3fd8e2$var$SLOT_SIZE + extra, $f43313d21d3fd8e2$var$SLOT_SIZE, $f43313d21d3fd8e2$var$SLOT_SIZE, color, lp, this.blackPipes);\n        }\n        if (this.brokenWalls) {\n            const that = this;\n            function drawBrokenWall(x, y, drawX, drawY) {\n                const color = getPipeColor(x, y);\n                const slot = that.grid[y][x];\n                const lp = that._lockParadigmOf(slot, x, y);\n                slot.draw(ctx, drawX, drawY, $f43313d21d3fd8e2$var$SLOT_SIZE, $f43313d21d3fd8e2$var$SLOT_SIZE, color, lp, that.blackPipes);\n                ctx.globalAlpha = 0.5;\n                ctx.fillStyle = \"white\";\n                ctx.fillRect(drawX, drawY, $f43313d21d3fd8e2$var$SLOT_SIZE, $f43313d21d3fd8e2$var$SLOT_SIZE);\n                ctx.globalAlpha = 1;\n            }\n            drawBrokenWall(this.width - 1, this.height - 1, -extra, -extra);\n            drawBrokenWall(0, this.height - 1, $f43313d21d3fd8e2$var$SLOT_SIZE * this.width + extra, -extra);\n            drawBrokenWall(0, 0, $f43313d21d3fd8e2$var$SLOT_SIZE * this.width + extra, $f43313d21d3fd8e2$var$SLOT_SIZE * this.height + extra);\n            drawBrokenWall(this.width - 1, 0, -extra, $f43313d21d3fd8e2$var$SLOT_SIZE * this.height + extra);\n            for(let x = 0; x != this.width; ++x){\n                drawBrokenWall(x, this.height - 1, $f43313d21d3fd8e2$var$SLOT_SIZE * x + extra, -extra);\n                drawBrokenWall(x, 0, $f43313d21d3fd8e2$var$SLOT_SIZE * x + extra, $f43313d21d3fd8e2$var$SLOT_SIZE * this.height + extra);\n            }\n            for(let y = 0; y != this.width; ++y){\n                drawBrokenWall(0, y, $f43313d21d3fd8e2$var$SLOT_SIZE * this.width + extra, $f43313d21d3fd8e2$var$SLOT_SIZE * y + extra);\n                drawBrokenWall(this.width - 1, y, -extra, $f43313d21d3fd8e2$var$SLOT_SIZE * y + extra);\n            }\n        }\n    }\n    _lockParadigmOf(slot, x, y) {\n        if (!slot.blocked) return $f43313d21d3fd8e2$var$LockParadigm.NotLocked;\n        else if (!this.fitsWithNearbyBlocked({\n            x: x,\n            y: y\n        })) return $f43313d21d3fd8e2$var$LockParadigm.LockedWithConflict;\n        else return $f43313d21d3fd8e2$var$LockParadigm.LockedOk;\n    }\n    fitsWithNearbyBlocked(point) {\n        const slot = this.get(point);\n        return undefined === this.getNeighboursOf(point).find(({ other: other, dir: dir })=>{\n            if (other === null) return slot[dir] === true;\n            else return other.blocked && slot[dir] !== other[(0, $461fef29bc99ab5c$export$5b8cb9ace9acd75e)(dir)];\n        });\n    }\n    exploreNetworkOf(x, y, memberConsumer) {\n        let explored = new Set();\n        explored.add(y + \",\" + x);\n        memberConsumer(x, y);\n        let toExplore = [\n            {\n                x: x,\n                y: y\n            }\n        ];\n        const explore = (x, y, myDir, hisDir, dx, dy)=>{\n            if (this.brokenWalls) {\n                if (x + dx < 0) dx += this.width;\n                if (y + dy < 0) dy += this.height;\n                if (x + dx === this.width) dx = -x;\n                if (y + dy === this.height) dy = -y;\n            } else {\n                if (x + dx < 0) return;\n                if (y + dy < 0) return;\n                if (x + dx >= this.width) return;\n                if (y + dy >= this.height) return;\n            }\n            const slot = this.grid[y][x];\n            if (!slot[myDir]) return;\n            const other = this.grid[y + dy][x + dx];\n            if (!other[hisDir]) return;\n            const code = `${y + dy},${x + dx}`;\n            if (explored.has(code)) return;\n            explored.add(code);\n            memberConsumer(x + dx, y + dy);\n            toExplore.push({\n                x: x + dx,\n                y: y + dy\n            });\n        };\n        while(toExplore.length !== 0){\n            const next = toExplore[toExplore.length - 1];\n            toExplore.splice(toExplore.length - 1, 1);\n            explore(next.x, next.y, \"north\", \"south\", 0, -1);\n            explore(next.x, next.y, \"south\", \"north\", 0, 1);\n            explore(next.x, next.y, \"east\", \"west\", 1, 0);\n            explore(next.x, next.y, \"west\", \"east\", -1, 0);\n        }\n    }\n    checkWin() {\n        let nb = 0;\n        this.exploreNetworkOf(0, 0, ()=>++nb);\n        return nb === this.width * this.height;\n    }\n    solve() {\n        for (const solved of (0, $24c03f35ab1abff0$export$2e2bcd8739ae039)(this)){\n            const slot = this.grid[solved.y][solved.x];\n            for(let i = 0; i != 4; ++i){\n                if (slot.north === solved.north && slot.south === solved.south && slot.east === solved.east && slot.west === solved.west) {\n                    slot.blocked = true;\n                    break;\n                }\n                slot.rotate();\n            }\n        }\n    }\n    shift(direction) {\n        if (!this.brokenWalls) return;\n        // Compute translation function\n        function loop(value, round) {\n            if (value >= round) return value % round;\n            while(value < 0)value += round;\n            return value;\n        }\n        let where;\n        if (direction === \"right\") where = (x, y)=>this.grid[y][loop(x - 1, this.width)];\n        else if (direction === \"left\") where = (x, y)=>this.grid[y][loop(x + 1, this.width)];\n        else if (direction === \"up\") where = (x, y)=>this.grid[loop(y + 1, this.height)][x];\n        else if (direction === \"down\") where = (x, y)=>this.grid[loop(y - 1, this.height)][x];\n        else return;\n        // Translate\n        let newGrid = [];\n        for(let y = 0; y != this.height; ++y){\n            let row = [];\n            for(let x = 0; x != this.width; ++x)row.push(where(x, y));\n            newGrid.push(row);\n        }\n        this.grid = newGrid;\n    }\n}\nfunction $f43313d21d3fd8e2$var$computeNetworks(self) {\n    const posToGroup = new Map();\n    let nextGroupId = 0;\n    for(let x = 0; x != self.width; ++x)for(let y = 0; y != self.height; ++y){\n        const pos1d = x + y * self.width;\n        if (!posToGroup.has(pos1d)) {\n            self.exploreNetworkOf(x, y, (x, y)=>posToGroup.set(x + y * self.width, nextGroupId));\n            ++nextGroupId;\n        }\n    }\n    const result = new Map();\n    for (const [pos1d, groupId] of posToGroup.entries())result.set(pos1d, [\n        \"blue\",\n        \"red\",\n        \"green\",\n        \"purple\"\n    ][groupId % 4]);\n    return result;\n}\nfunction $f43313d21d3fd8e2$var$setCanvasSize(canvas, width, height) {\n    const style = canvas.style;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    canvas.width = width;\n    canvas.height = height;\n}\nconst $f43313d21d3fd8e2$var$DEFAULT_SETTINGS = {\n    width: 5,\n    height: 5,\n    broken: false\n};\nwindow.onload = ()=>{\n    document.getElementById(\"width\").value = $f43313d21d3fd8e2$var$DEFAULT_SETTINGS.width.toString();\n    document.getElementById(\"height\").value = $f43313d21d3fd8e2$var$DEFAULT_SETTINGS.height.toString();\n    document.getElementById(\"broken\").checked = $f43313d21d3fd8e2$var$DEFAULT_SETTINGS.broken;\n    const canvas = document.getElementById(\"maze\");\n    function setupNewGrid() {\n        let trueMaze = new $f43313d21d3fd8e2$var$PlayerMaze(parseInt(document.getElementById(\"width\").value), parseInt(document.getElementById(\"height\").value), !!document.getElementById(\"broken\").checked);\n        const extra = trueMaze.brokenWalls ? $f43313d21d3fd8e2$var$SLOT_SIZE / 2 : 0;\n        $f43313d21d3fd8e2$var$setCanvasSize(canvas, $f43313d21d3fd8e2$var$SLOT_SIZE * trueMaze.width + extra * 2, $f43313d21d3fd8e2$var$SLOT_SIZE * trueMaze.height + extra * 2);\n        trueMaze.draw(canvas);\n        return trueMaze;\n    }\n    let trueMaze = setupNewGrid();\n    document.getElementById(\"reset\").onclick = ()=>trueMaze = setupNewGrid();\n    function getClickedSlot(event) {\n        let x = event.clientX - canvas.getBoundingClientRect().x;\n        let y = event.clientY - canvas.getBoundingClientRect().y;\n        if (trueMaze.brokenWalls) {\n            x -= $f43313d21d3fd8e2$var$SLOT_SIZE / 2;\n            y -= $f43313d21d3fd8e2$var$SLOT_SIZE / 2;\n        }\n        const slotX = Math.floor(x / $f43313d21d3fd8e2$var$SLOT_SIZE);\n        const slotY = Math.floor(y / $f43313d21d3fd8e2$var$SLOT_SIZE);\n        if (slotX >= 0 && slotY >= 0 && slotX < trueMaze.width && slotY < trueMaze.height) return {\n            type: \"slot\",\n            x: slotX,\n            y: slotY,\n            slot: trueMaze.grid[slotY][slotX]\n        };\n        else if (trueMaze.brokenWalls) {\n            let result = {\n                type: \"movement\",\n                directions: []\n            };\n            if (slotX < 0) result.directions.push(\"right\");\n            if (slotY < 0) result.directions.push(\"down\");\n            if (slotX >= trueMaze.width) result.directions.push(\"left\");\n            if (slotY >= trueMaze.height) result.directions.push(\"up\");\n            return result;\n        } else return {\n            type: \"void\"\n        };\n        if (type == \"slot\" && x >= 0 && y >= 0 && x < trueMaze.width && y < trueMaze.height) return trueMaze.grid[y][x];\n        else return null;\n    }\n    canvas.addEventListener(\"click\", (event)=>{\n        const clickedOn = getClickedSlot(event);\n        if (clickedOn.type == \"slot\") {\n            $f43313d21d3fd8e2$var$rotateSlot(clickedOn.slot, clickedOn.x, clickedOn.y, trueMaze);\n            trueMaze.draw(canvas);\n        } else if (clickedOn.type == \"movement\") {\n            for (const move of clickedOn.directions)trueMaze.shift(move);\n            trueMaze.draw(canvas);\n        }\n    });\n    canvas.addEventListener(\"contextmenu\", (event)=>{\n        event.preventDefault();\n        const clickedOn = getClickedSlot(event);\n        if (clickedOn.type == \"slot\") {\n            const slot = clickedOn.slot;\n            slot.blocked = !slot.blocked;\n            trueMaze.draw(canvas);\n        }\n        return false;\n    });\n    document.addEventListener(\"keypress\", (event)=>{\n        const e = event || window.event;\n        if (e.key === \"d\") {\n            trueMaze.shift(\"right\");\n            trueMaze.draw(canvas);\n        } else if (e.key === \"q\" || e.key === \"a\") {\n            trueMaze.shift(\"left\");\n            trueMaze.draw(canvas);\n        } else if (e.key === \"s\") {\n            trueMaze.shift(\"down\");\n            trueMaze.draw(canvas);\n        } else if (e.key === \"z\" || e.key === \"w\") {\n            trueMaze.shift(\"up\");\n            trueMaze.draw(canvas);\n        } else if (e.key === \"c\") {\n            trueMaze.invertColorDisplay();\n            trueMaze.draw(canvas);\n        } else if (e.key === \"m\") {\n            trueMaze.solve();\n            trueMaze.draw(canvas);\n        }\n        return false;\n    });\n};\n\n\n//# sourceMappingURL=index.d072d556.js.map\n","import mazeGenerator from './maze-generator';\r\nimport gridSolver from './grid-solver';\r\nimport { Dir, Dirs, Dir_opposite } from './base/dir';\r\nimport { Grid } from './base/abstract-grid';\r\nimport { Point2D, Slot } from './base/grid-component';\r\n\r\n\r\nconst SLOT_SIZE = 100;\r\nconst LINE_SIZE = 20;\r\n\r\nenum LockParadigm {\r\n  LockedOk,\r\n  LockedWithConflict,\r\n  NotLocked\r\n}\r\n\r\nenum Playstyle { Free, Restrained, AutoLock }\r\n\r\nfunction lockParadigmToStyle(lockedParadigm: LockParadigm): string {\r\n  switch (lockedParadigm) {\r\n    case LockParadigm.LockedOk: return 'darkgrey';\r\n    case LockParadigm.LockedWithConflict: return 'red';\r\n    case LockParadigm.NotLocked: return 'lightgrey'\r\n    default: return 'green';\r\n  }\r\n}\r\n\r\nfunction getCurrentPlaystyle(): Playstyle {\r\n  const select = document.getElementById('qol_spin') as HTMLSelectElement;\r\n  if (select.value === 'autolock') return Playstyle.AutoLock;\r\n  else if (select.value === 'restrained') return Playstyle.Restrained;\r\n  else return Playstyle.Free;\r\n}\r\n\r\nfunction rotateSlot(slot: RealSlot, x: number, y: number, maze: PlayerMaze) {\r\n  if (slot.blocked) return;\r\n\r\n  const slotPoint = { x, y };\r\n\r\n  const playstyle = getCurrentPlaystyle();\r\n  if (playstyle === Playstyle.AutoLock || playstyle === Playstyle.Restrained) {\r\n    let goodFits: [boolean, boolean, boolean, boolean] = [false, false, false, false];\r\n    for (let i = 0; i != 4; ++i) {\r\n      slot.rotate();\r\n      goodFits[i] = maze.fitsWithNearbyBlocked(slotPoint);\r\n    }\r\n\r\n    let nbOfGoodFits = goodFits.filter(x => x).length;\r\n\r\n    if (slot.isABar()) nbOfGoodFits /= 2;\r\n\r\n    if (playstyle === Playstyle.AutoLock && nbOfGoodFits === 1) {\r\n      while (!maze.fitsWithNearbyBlocked(slotPoint)) {\r\n        slot.rotate();\r\n      }\r\n\r\n      slot.blocked = true;\r\n    } else if ((playstyle === Playstyle.Restrained || playstyle === Playstyle.AutoLock) && nbOfGoodFits > 0) {\r\n      slot.rotate();\r\n      while (!maze.fitsWithNearbyBlocked(slotPoint)) {\r\n        slot.rotate();\r\n      }\r\n    } else {\r\n      slot.rotate();\r\n    }\r\n  } else {\r\n    slot.rotate();\r\n  }\r\n}\r\n\r\nclass RealSlot {\r\n  north: boolean = false;\r\n  east: boolean = false;\r\n  west: boolean = false;\r\n  south: boolean = false;\r\n  blocked: boolean = false;\r\n\r\n  countPaths() {\r\n    return Dirs.map(dir => this[dir]).filter(x => x).length;\r\n  }\r\n\r\n  isABar() {\r\n    return this.north == this.south && this.west == this.east && this.north !== this.west;\r\n  }\r\n\r\n  draw(context: CanvasRenderingContext2D,\r\n    x: number, y: number, width: number, height: number,\r\n    pipeStyle: string, lockParadigm: LockParadigm, drawOnePath: boolean\r\n  ) {\r\n    context.fillStyle = 'black';\r\n    context.fillRect(x, y, width, height);\r\n    context.fillStyle = lockParadigmToStyle(lockParadigm);\r\n    context.fillRect(x + 1, y + 1, width - 2, height - 2);\r\n\r\n    context.fillStyle = pipeStyle;\r\n\r\n    if (this.north) context.fillRect(x + (width / 2) - (LINE_SIZE / 2), y                         , LINE_SIZE, height / 2);\r\n    if (this.south) context.fillRect(x + (width / 2) - (LINE_SIZE / 2), y + (height / 2)          , LINE_SIZE, height / 2);\r\n    if (this.west ) context.fillRect(x                        , y + (height / 2) - (LINE_SIZE / 2), width / 2, LINE_SIZE);\r\n    if (this.east ) context.fillRect(x + (width / 2)          , y + (height / 2) - (LINE_SIZE / 2), width / 2, LINE_SIZE);\r\n\r\n    if (this.countPaths() === 1) {\r\n      if (drawOnePath) context.fillStyle = 'blue';\r\n      context.fillRect(\r\n        x + (width  / 2) - (LINE_SIZE / 2),\r\n        y + (height / 2) - (LINE_SIZE / 2),\r\n        LINE_SIZE, LINE_SIZE\r\n      );\r\n    }\r\n  }\r\n\r\n  rotate() {\r\n    if (this.blocked) return;\r\n    let temp = this.north;\r\n    this.north = this.east;\r\n    this.east = this.south;\r\n    this.south = this.west;\r\n    this.west = temp;\r\n  }\r\n}\r\n\r\nclass PlayerMaze extends Grid<RealSlot> {\r\n  grid: RealSlot[][];\r\n  \r\n  blackPipes: boolean = true;\r\n\r\n  readonly width: number;\r\n  readonly height: number;\r\n  readonly brokenWalls: boolean;\r\n\r\n  constructor(width: number, height: number, brokenWalls: boolean = false) {\r\n    super();\r\n\r\n    this.width = width;\r\n    this.height = height;\r\n    this.brokenWalls = brokenWalls;\r\n\r\n    // ==== 1) Initial grid\r\n    const configuration = mazeGenerator({ width, height, brokenWalls });\r\n\r\n    this.grid = [];\r\n\r\n    for (let y = 0; y != height; ++y) {\r\n      let row: RealSlot[] = [];\r\n      for (let x = 0; x != width; ++x) {\r\n        const config = configuration[y][x];\r\n        const slot = new RealSlot();\r\n        Object.assign(slot, config);\r\n\r\n        for (let rotate = Math.floor(Math.random() * 4); rotate >= 0; --rotate) {\r\n          slot.rotate();\r\n        }\r\n\r\n        row.push(slot);\r\n      }\r\n      this.grid.push(row);\r\n    }\r\n  }\r\n\r\n  get(point: Point2D) {\r\n    return this.grid[point.y][point.x];\r\n  }\r\n\r\n\r\n  invertColorDisplay() { this.blackPipes = !this.blackPipes; }\r\n\r\n  draw(canvas: HTMLCanvasElement) {\r\n    let getPipeColor: (x: number, y: number) => string;\r\n    if (this.blackPipes) {\r\n      if (this.checkWin()) getPipeColor = () => 'blue';\r\n      else getPipeColor = () => 'black';\r\n    } else {\r\n      const mapping: Map<number, string> = computeNetworks(this);\r\n      getPipeColor = (x: number, y: number) => mapping.get(x + y * this.width) || 'black';\r\n    }\r\n\r\n    const ctx = canvas.getContext('2d')!;\r\n\r\n    const extra = this.brokenWalls ? SLOT_SIZE / 2 : 0;\r\n\r\n    ctx.fillStyle = 'red';\r\n    ctx.fillRect(0, 0, this.width * SLOT_SIZE + extra * 2, this.height * SLOT_SIZE + extra * 2);\r\n\r\n    for (let y = 0; y != this.height; ++y) {\r\n      for (let x = 0; x != this.width; ++x) {\r\n        const color = getPipeColor(x, y);\r\n        const slot = this.grid[y][x];\r\n        const lp = this._lockParadigmOf(slot, x, y);\r\n        slot.draw(ctx, x * SLOT_SIZE + extra, y * SLOT_SIZE + extra, SLOT_SIZE, SLOT_SIZE, color, lp, this.blackPipes);\r\n      }\r\n    }\r\n\r\n    if (this.brokenWalls) {\r\n      const that = this;\r\n\r\n      function drawBrokenWall(x: number, y: number, drawX: number, drawY: number) {\r\n        const color = getPipeColor(x, y);\r\n        const slot = that.grid[y][x];\r\n        const lp = that._lockParadigmOf(slot, x, y);\r\n        slot.draw(ctx, drawX, drawY, SLOT_SIZE, SLOT_SIZE, color, lp, that.blackPipes);\r\n  \r\n        ctx.globalAlpha = 0.5;\r\n        ctx.fillStyle = \"white\";\r\n        ctx.fillRect(drawX, drawY, SLOT_SIZE, SLOT_SIZE);\r\n        ctx.globalAlpha = 1;\r\n      }\r\n\r\n      drawBrokenWall(this.width - 1, this.height - 1,                        - extra,                         - extra);\r\n      drawBrokenWall(0             , this.height - 1, SLOT_SIZE * this.width + extra,                         - extra);\r\n      drawBrokenWall(0             , 0              , SLOT_SIZE * this.width + extra, SLOT_SIZE * this.height + extra);\r\n      drawBrokenWall(this.width - 1, 0              ,                        - extra, SLOT_SIZE * this.height + extra);\r\n\r\n      for (let x = 0; x != this.width; ++x) {\r\n        drawBrokenWall(x, this.height - 1, SLOT_SIZE * x + extra,                         - extra);\r\n        drawBrokenWall(x, 0              , SLOT_SIZE * x + extra, SLOT_SIZE * this.height + extra);\r\n      }\r\n      \r\n      for (let y = 0; y != this.width; ++y) {\r\n        drawBrokenWall(0             , y              , SLOT_SIZE * this.width + extra, SLOT_SIZE * y + extra);\r\n        drawBrokenWall(this.width - 1, y              ,                        - extra, SLOT_SIZE * y + extra);\r\n      }\r\n    }\r\n  }\r\n\r\n  _lockParadigmOf(slot: RealSlot, x: number, y: number) {\r\n    if (!slot.blocked) {\r\n      return LockParadigm.NotLocked;\r\n    } else if (!this.fitsWithNearbyBlocked({ x, y })) {\r\n      return LockParadigm.LockedWithConflict;\r\n    } else {\r\n      return LockParadigm.LockedOk;\r\n    }\r\n  }\r\n\r\n  fitsWithNearbyBlocked(point: Point2D): boolean {\r\n    const slot = this.get(point);\r\n    return undefined === this.getNeighboursOf(point)\r\n    .find(({ other, dir }) => {\r\n      if (other === null) {\r\n        return slot[dir] === true;\r\n      } else{\r\n        return other.blocked && slot[dir] !== other[Dir_opposite(dir)];\r\n      }\r\n    });\r\n  }\r\n\r\n  exploreNetworkOf(x: number, y: number, memberConsumer: (x: number, y: number) => void) {\r\n    let explored = new Set<string>();\r\n    explored.add(y + ',' + x);\r\n    memberConsumer(x, y);\r\n    let toExplore: { x: number, y: number }[] = [{ x: x, y: y }];\r\n\r\n    const explore = (x: number, y: number, myDir: Dir, hisDir: Dir, dx: number, dy: number) => {\r\n      if (this.brokenWalls) {\r\n        if (x + dx < 0) dx += this.width;\r\n        if (y + dy < 0) dy += this.height;\r\n        if (x + dx === this.width) dx = -x;\r\n        if (y + dy === this.height) dy = -y;\r\n      } else {\r\n        if (x + dx < 0) return;\r\n        if (y + dy < 0) return;\r\n        if (x + dx >= this.width) return;\r\n        if (y + dy >= this.height) return;\r\n      }\r\n\r\n      const slot = this.grid[y][x];\r\n      if (!slot[myDir]) return;\r\n\r\n      const other = this.grid[y + dy][x + dx];\r\n      if (!other[hisDir]) return;\r\n      const code = `${y + dy},${x + dx}`;\r\n      if (explored.has(code)) return;\r\n      explored.add(code);\r\n      memberConsumer(x + dx, y + dy);\r\n      toExplore.push({ x: x + dx, y: y + dy });\r\n    };\r\n\r\n    while (toExplore.length !== 0) {\r\n      const next = toExplore[toExplore.length - 1];\r\n      toExplore.splice(toExplore.length - 1, 1);\r\n\r\n      explore(next.x, next.y, 'north', 'south', 0, -1);\r\n      explore(next.x, next.y, 'south', 'north', 0, 1);\r\n      explore(next.x, next.y, 'east', 'west', 1, 0);\r\n      explore(next.x, next.y, 'west', 'east', -1, 0);\r\n    }\r\n  }\r\n\r\n  checkWin() {\r\n    let nb = 0;\r\n    this.exploreNetworkOf(0, 0, () => ++nb);\r\n    return nb === this.width * this.height;\r\n  }\r\n\r\n  solve() {\r\n    for (const solved of gridSolver(this)) {\r\n      const slot = this.grid[solved.y][solved.x];\r\n\r\n      for (let i = 0; i != 4; ++i) {\r\n        if (slot.north === solved.north\r\n          && slot.south === solved.south\r\n          && slot.east === solved.east\r\n          && slot.west === solved.west) { \r\n          slot.blocked = true;\r\n          break;\r\n        }\r\n\r\n        slot.rotate();\r\n      }\r\n    }\r\n  }\r\n\r\n  shift(direction: 'right' | 'left' | 'up' | 'down') {\r\n    if (!this.brokenWalls) return;\r\n\r\n    // Compute translation function\r\n    function loop(value: number, round: number) {\r\n      if (value >= round) return value % round;\r\n      while (value < 0) {\r\n        value += round;\r\n      }\r\n      return value;\r\n    }\r\n\r\n    let where: (x: number, y: number) => RealSlot;\r\n    if (direction === 'right') {\r\n      where = (x: number, y: number) => this.grid[y][loop(x - 1, this.width)];\r\n    } else if (direction === 'left') {\r\n      where = (x: number, y: number) => this.grid[y][loop(x + 1, this.width)];\r\n    } else if (direction === 'up') {\r\n      where = (x: number, y: number) => this.grid[loop(y + 1, this.height)][x];\r\n    } else if (direction === 'down') {\r\n      where = (x: number, y: number) => this.grid[loop(y - 1, this.height)][x];\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    // Translate\r\n    let newGrid: RealSlot[][] = [];\r\n    for (let y = 0; y != this.height; ++y) {\r\n      let row: RealSlot[] = [];\r\n      for (let x = 0; x != this.width; ++x) {\r\n        row.push(where(x, y));\r\n      }\r\n      newGrid.push(row);\r\n    }\r\n    this.grid = newGrid;\r\n  }\r\n}\r\n\r\nfunction computeNetworks(self: PlayerMaze): Map<number, string> {\r\n  const posToGroup = new Map<number, number>();\r\n\r\n  let nextGroupId = 0;\r\n  for (let x = 0; x != self.width; ++x) {\r\n    for (let y = 0; y != self.height; ++y) {\r\n      const pos1d = x + y * self.width;\r\n      if (!posToGroup.has(pos1d)) {\r\n        self.exploreNetworkOf(x, y, (x, y) => posToGroup.set(x + y * self.width, nextGroupId));\r\n        ++nextGroupId;\r\n      }\r\n    }\r\n  }\r\n\r\n  const result = new Map<number, string>();\r\n  for (const [pos1d, groupId] of posToGroup.entries()) {\r\n    result.set(pos1d, ['blue', 'red', 'green', 'purple'][groupId % 4])\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction setCanvasSize(canvas: HTMLCanvasElement, width: number, height: number) {\r\n  const style = canvas.style;\r\n  style.width  = `${width}px`;\r\n  style.height = `${height}px`;\r\n\r\n  canvas.width  = width;\r\n  canvas.height = height;\r\n}\r\n\r\nconst DEFAULT_SETTINGS = {\r\n  width: 5,\r\n  height: 5,\r\n  broken: false\r\n};\r\n\r\nwindow.onload = () => {\r\n  (document.getElementById(\"width\") as HTMLInputElement).value = DEFAULT_SETTINGS.width.toString();\r\n  (document.getElementById(\"height\") as HTMLInputElement).value = DEFAULT_SETTINGS.height.toString();\r\n  (document.getElementById(\"broken\") as any).checked = DEFAULT_SETTINGS.broken;\r\n\r\n  const canvas = document.getElementById(\"maze\") as HTMLCanvasElement;\r\n\r\n  function setupNewGrid(): PlayerMaze {\r\n    let trueMaze = new PlayerMaze(\r\n      parseInt((document.getElementById(\"width\") as HTMLInputElement).value),\r\n      parseInt((document.getElementById(\"height\") as HTMLInputElement).value),\r\n      !!(document.getElementById(\"broken\") as HTMLInputElement).checked\r\n    );\r\n\r\n    const extra = trueMaze.brokenWalls ? SLOT_SIZE / 2 : 0;\r\n\r\n    setCanvasSize(canvas, SLOT_SIZE * trueMaze.width + extra * 2, SLOT_SIZE * trueMaze.height + extra * 2);\r\n    trueMaze.draw(canvas);\r\n    return trueMaze;\r\n  }\r\n\r\n  let trueMaze = setupNewGrid();\r\n  document.getElementById(\"reset\")!.onclick = () => trueMaze = setupNewGrid()\r\n\r\n  function getClickedSlot(event: MouseEvent)\r\n    : { type: 'void' }\r\n    | { type: 'slot', x: number, y: number, slot: RealSlot }\r\n    | { type: 'movement', directions: ('right' | 'down' | 'up' | 'left')[] }\r\n  {\r\n    let x = event.clientX - canvas.getBoundingClientRect().x;\r\n    let y = event.clientY - canvas.getBoundingClientRect().y;\r\n\r\n    if (trueMaze.brokenWalls) {\r\n      x -= SLOT_SIZE / 2;\r\n      y -= SLOT_SIZE / 2;\r\n    }\r\n\r\n    const slotX = Math.floor(x / SLOT_SIZE);\r\n    const slotY = Math.floor(y / SLOT_SIZE);\r\n\r\n    if (slotX >= 0 && slotY >= 0 && slotX < trueMaze.width && slotY < trueMaze.height) {\r\n      return { type: 'slot', x: slotX, y: slotY, slot: trueMaze.grid[slotY][slotX] };\r\n    } else if (trueMaze.brokenWalls) {\r\n      let result = { type: 'movement' as const, directions: [] as ('right' | 'down' | 'up' | 'left')[] };\r\n\r\n      if (slotX < 0) result.directions.push('right');\r\n      if (slotY < 0) result.directions.push('down');\r\n      if (slotX >= trueMaze.width) result.directions.push('left');\r\n      if (slotY >= trueMaze.height) result.directions.push('up');\r\n\r\n      return result;\r\n    } else{\r\n      return { type: 'void' };\r\n    }\r\n    \r\n    if (type == 'slot' && x >= 0 && y >= 0 && x < trueMaze.width && y < trueMaze.height) {\r\n      return trueMaze.grid[y][x];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  canvas.addEventListener('click', event => {\r\n    const clickedOn = getClickedSlot(event);\r\n\r\n    if (clickedOn.type == 'slot') {\r\n      rotateSlot(clickedOn.slot, clickedOn.x, clickedOn.y, trueMaze);\r\n      trueMaze.draw(canvas);\r\n    } else if (clickedOn.type == 'movement') {\r\n      for (const move of clickedOn.directions) {\r\n        trueMaze.shift(move);\r\n      }\r\n\r\n      trueMaze.draw(canvas);\r\n    }\r\n  });\r\n\r\n  canvas.addEventListener('contextmenu', event => {\r\n    event.preventDefault();\r\n\r\n    const clickedOn = getClickedSlot(event);\r\n    if (clickedOn.type == 'slot') {\r\n      const slot = clickedOn.slot;\r\n      slot.blocked = !slot.blocked;\r\n      trueMaze.draw(canvas);\r\n    }\r\n\r\n    return false;\r\n  });\r\n\r\n  document.addEventListener('keypress', event => {\r\n    const e = event || window.event;\r\n\r\n    if (e.key === 'd') {\r\n      trueMaze.shift('right');\r\n      trueMaze.draw(canvas);\r\n    } else if (e.key === 'q' || e.key === 'a') {\r\n      trueMaze.shift('left');\r\n      trueMaze.draw(canvas);\r\n    } else if (e.key === 's') {\r\n      trueMaze.shift('down');\r\n      trueMaze.draw(canvas);\r\n    } else if (e.key === 'z' || e.key === 'w') {\r\n      trueMaze.shift('up');\r\n      trueMaze.draw(canvas);\r\n    } else if (e.key === 'c') {\r\n      trueMaze.invertColorDisplay();\r\n      trueMaze.draw(canvas);\r\n    } else if (e.key === 'm') {\r\n      trueMaze.solve();\r\n      trueMaze.draw(canvas);\r\n    }\r\n\r\n    return false;\r\n  });\r\n\r\n};\r\n","import { Dir_opposite } from \"./base/dir\";\r\nimport { GridConfiguration, Point2D, Point2D_move, Slot } from \"./base/grid-component\";\r\n\r\n/*\r\n * This file produces maze from an empty grid. The maze is the starting point\r\n * of the game: it will then be shuffled and the player's goal is to find back\r\n * the original maze.\r\n */\r\n\r\n/** Either east or south */\r\ntype LimitedDir = 'east' | 'south';\r\n\r\n/** A door, i.e. broken wall */\r\ntype Door = Point2D & { to: LimitedDir };\r\n\r\n/**\r\n * A mapping of slots to their group\r\n * \r\n * Uses the Union-Find algorithm:\r\n * https://en.wikipedia.org/wiki/Disjoint-set_data_structure\r\n */\r\nclass UnionFind {\r\n  /** Slot index on a 1D scale to group id */\r\n  #slotToGroup: Map<number, number>;\r\n  /** Number of slots per line, used to compute the index on a 1D scale */\r\n  #width: number;\r\n\r\n  constructor(width: number, height: number) {\r\n    this.#width = width;\r\n    this.#slotToGroup = new Map<number, number>();\r\n    \r\n    // makeSet\r\n    for (let i = 0; i != width * height; ++i) {\r\n      this.#slotToGroup.set(i, i);\r\n    }\r\n  }\r\n\r\n  /** Return the root of the tree in which the given slot is */\r\n  find(slot: Point2D) {\r\n    let expected = slot.x + slot.y * this.#width;\r\n    \r\n    while (true) {\r\n      let realGroupId = this.#slotToGroup.get(expected)!;\r\n      if (realGroupId === expected) return expected;\r\n      expected = realGroupId;\r\n    }\r\n  }\r\n\r\n  /** Merge the trees where slot1 and slot2 are */\r\n  union(slot1: Point2D, slot2: Point2D) {\r\n    this.#slotToGroup.set(this.find(slot1), this.find(slot2));\r\n  }\r\n}\r\n\r\n/**\r\n * Builds the list of place where a wall can be broken. Two lists are returned:\r\n * one for horizontal walls (east to west) and one for vertical walls\r\n * (north to south).\r\n * @param gridConf The grid configuration\r\n * @returns The list of slots where there are breakable walls\r\n */\r\nfunction initWalls(gridConf: GridConfiguration): { h: Point2D[], v: Point2D[] } {\r\n  const h: Point2D[] = [];\r\n  const v: Point2D[] = [];\r\n\r\n  const notBroken = gridConf.brokenWalls ? 0 : 1;\r\n\r\n  for (let x = 0; x != gridConf.width; ++x) {\r\n    for (let y = 0; y != gridConf.height; ++y) {\r\n      if (x != gridConf.width - notBroken) h.push({ x, y });\r\n      if (y != gridConf.height - notBroken) v.push({ x, y });\r\n    }\r\n  }\r\n\r\n  return { h, v };\r\n}\r\n\r\n/**\r\n * Builds the list of walls to open\r\n * @param gridConf The grid configuration\r\n * @returns The list of walls to open\r\n */\r\nfunction buildOpenWalls(gridConf: GridConfiguration): Door[] {\r\n  const groups = new UnionFind(gridConf.width, gridConf.height);\r\n  const { h, v } = initWalls(gridConf);\r\n\r\n  let numberOfDiffGroups = gridConf.width * gridConf.height;\r\n\r\n  let res: Door[] = [];\r\n\r\n  let openedWalls = new Map<number, number>();\r\n  const breakable = (slot: Point2D) => {\r\n    let cnt = openedWalls.get(slot.x + slot.y * gridConf.width);\r\n    if (cnt === undefined) return true;\r\n    if (cnt >= 3) return false;\r\n    return true;\r\n  }\r\n\r\n  while (numberOfDiffGroups > 1) {\r\n    const breakHorizontal = Math.random() >= 0.5;\r\n    const dir: LimitedDir = breakHorizontal ? 'east' : 'south';\r\n    const wallsToBreak = breakHorizontal ? h : v;\r\n    if (wallsToBreak.length === 0) continue;\r\n\r\n    const randomIndex = Math.floor(Math.random() * wallsToBreak.length);\r\n    const slot1 = wallsToBreak[randomIndex];\r\n    const slot2 = Point2D_move(slot1, dir, gridConf)!;\r\n\r\n    wallsToBreak.splice(randomIndex, 1);\r\n    \r\n    if (!breakable(slot1) || !breakable(slot2)) continue;\r\n\r\n    if (groups.find(slot1) !== groups.find(slot2)) {\r\n      res.push({ x: slot1.x, y: slot1.y, to: dir });\r\n      groups.union(slot1, slot2);\r\n      --numberOfDiffGroups;\r\n\r\n      const g1 = slot1.x + slot1.y * gridConf.width;\r\n      openedWalls.set(g1, (openedWalls.get(g1) || 0) + 1);\r\n      const g2 = slot2.x + slot2.y * gridConf.width;\r\n      openedWalls.set(g2, (openedWalls.get(g2) || 0) + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n/** Builds an initial grid with no pipe */\r\nfunction initializeMaze(gridConf: GridConfiguration): Slot<boolean>[][] {\r\n  const theMaze: Slot<boolean>[][] = [];\r\n  for (let row = 0; row != gridConf.height; ++row) {\r\n    const theRow: Slot<boolean>[] = [];\r\n    for (let col = 0; col != gridConf.width; ++col) {\r\n      theRow.push({ north: false, east: false, west: false, south: false });\r\n    }\r\n    theMaze.push(theRow);\r\n  }\r\n  return theMaze;\r\n}\r\n\r\n/**\r\n * Generates a maze\r\n * @param gridConf The grid configuration\r\n * @returns A 2D array, row-major, with the slots\r\n * @see https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_de_labyrinthe#Fusion_al%C3%A9atoire_de_chemins\r\n */\r\nexport default function generateMaze(gridConf: GridConfiguration): Slot[][] {\r\n  const maze = initializeMaze(gridConf);\r\n\r\n  for (const { x, y, to } of buildOpenWalls(gridConf)) {\r\n    const origin = { x, y };\r\n    const neighbour = Point2D_move(origin, to, gridConf)!;\r\n    maze[origin.y][origin.x][to] = true;\r\n    maze[neighbour.y][neighbour.x][Dir_opposite(to)] = true;\r\n  }\r\n\r\n  return maze;\r\n}\r\n","\r\n/** Possible directions */\r\nexport type Dir = 'north' | 'east' | 'west' | 'south';\r\n\r\n/** Every possible directions */\r\nexport const Dirs: Dir[] = ['north', 'east', 'west', 'south'];\r\n\r\n/**\r\n * Return the opposite direction\r\n * @param dir The direction\r\n * @returns The opposite direction\r\n */\r\nexport function Dir_opposite(dir: Dir): Dir {\r\n  switch (dir) {\r\n    case 'north': return 'south';\r\n    case 'south': return 'north';\r\n    case 'west': return 'east';\r\n    case 'east': return 'west';\r\n    default: throw Error(\"Unknown dir\");\r\n  }\r\n}\r\n","import { Dir } from \"./dir\";\r\n\r\n/** A Point in a 2D environment */\r\nexport type Point2D = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\n/** Converts the Point2D into a string */\r\nexport function Point2D_toString(self: Point2D) {\r\n  return `${self.y},${self.x}`\r\n}\r\n\r\nexport function Point2D_move(self: Point2D, dir: Dir, gridConf: GridConfiguration): Point2D | null;\r\nexport function Point2D_move(self: Point2D, dir: Dir, gridConf: GridConfiguration & { brokenWalls: true }): Point2D;\r\n\r\n/**\r\n * Builds a new point from the given point and the direction\r\n * @param self The point\r\n * @param dir The direction\r\n * @param gridConf The configuration of the grid\r\n * @returns The new point\r\n */\r\nexport function Point2D_move(self: Point2D, dir: Dir, gridConf: GridConfiguration): Point2D | null {\r\n  const copy = Object.assign({}, self);\r\n  switch (dir) {\r\n    case 'north': if (copy.y !== 0) { --copy.y } else { if (gridConf.brokenWalls) { copy.y = gridConf.height - 1 } else { return null; } } break;\r\n    case 'south': if (copy.y !== gridConf.height - 1) { ++copy.y } else { if (gridConf.brokenWalls) { copy.y = 0 } else { return null; } } break;\r\n    case 'east' : if (copy.x !== gridConf.width - 1)  { ++copy.x } else { if (gridConf.brokenWalls) { copy.x = 0 } else { return null; } } break;\r\n    case 'west' : if (copy.x !== 0) { --copy.x } else { if (gridConf.brokenWalls) { copy.x = gridConf.width - 1 } else { return null; } } break;\r\n  }\r\n\r\n  return copy;\r\n}\r\n\r\n/** A grid configuration */\r\nexport type GridConfiguration = {\r\n  width: number;\r\n  height: number;\r\n  brokenWalls: boolean;\r\n}\r\n\r\n/** A slot in a 2D grid with directions */\r\nexport type Slot<T = boolean> = {[dir in Dir]: T};\r\n\r\n/** Returns the number of outputs of the slot */\r\nexport function Slot_nbOfOutputs(slot: Slot<boolean>): 0 | 1 | 2 | 3 | 4 {\r\n  return ((slot.north) ? 1 : 0)\r\n  + ((slot.south) ? 1 : 0)\r\n  + ((slot.east) ? 1 : 0)\r\n  + ((slot.west) ? 1 : 0) as (0 | 1 | 2 | 3 | 4);\r\n}\r\n","import { Dir, Dirs, Dir_opposite } from \"./base/dir\";\r\nimport { Grid, Grid_ } from \"./base/abstract-grid\";\r\nimport { Point2D, Point2D_toString, Slot, Slot_nbOfOutputs } from \"./base/grid-component\";\r\nimport { InstanciatedSlot } from \"./gridapi\";\r\nimport { DirStatus, Form, instanciatedToSolvationSlot, NewlySolvedSlot, ResearchSlot, ResearchSlot_tryFinalize, SolvationSlot, SolvationSlot_clone } from \"./solver/component\";\r\n\r\n\r\nexport class SolvationGrid extends Grid<SolvationSlot> {\r\n  get width(): number { return this.ruleset.width; }\r\n  get height(): number { return this.ruleset.height; }\r\n  get brokenWalls(): boolean { return this.ruleset.brokenWalls; }\r\n\r\n  get(point: Point2D): SolvationSlot {\r\n    return this._slots[point.y][point.x];\r\n  }\r\n\r\n  _slots: SolvationSlot[][];\r\n  readonly ruleset: Grid_;\r\n\r\n  private constructor(theSlots: SolvationSlot[][], original: Grid_) {\r\n    super();\r\n    this._slots = theSlots;\r\n    this.ruleset = original;\r\n  }\r\n\r\n  static fromIGrid(grid: Grid<InstanciatedSlot>): SolvationGrid {\r\n    let theSlots: SolvationSlot[][] = [];\r\n\r\n    for (let y = 0; y !== grid.height; ++y) {\r\n      let row: SolvationSlot[] = [];\r\n      for (let x = 0; x !== grid.width; ++x) {\r\n        row.push(instanciatedToSolvationSlot(grid.get({ x, y })!));\r\n      }\r\n      theSlots.push(row);\r\n    }\r\n\r\n    return new SolvationGrid(theSlots, grid);\r\n  }\r\n\r\n  clone(): SolvationGrid {\r\n    let theSlots: SolvationSlot[][] = [];\r\n\r\n    for (let y = 0; y !== this.height; ++y) {\r\n      let row: SolvationSlot[] = [];\r\n      for (let x = 0; x !== this.width; ++x) {\r\n        row.push(SolvationSlot_clone(this._slots[y][x]));\r\n      }\r\n      theSlots.push(row);\r\n    }\r\n\r\n    return new SolvationGrid(theSlots, this);\r\n  }\r\n\r\n  solveSomeSlots(newSolutions: NewlySolvedSlot[]): boolean | 'bad' {\r\n    let unstable = false;\r\n    for (let row = 0; row !== this.height; ++row) {\r\n      for (let col = 0; col !== this.width; ++col) {\r\n        const notStable = this.solveAt({ x: col, y: row }, newSolutions);\r\n        if (notStable === 'bad') return 'bad';\r\n        unstable ||= notStable;\r\n      }\r\n    }\r\n    return unstable;\r\n  }\r\n\r\n  solveAt(point: Point2D, newSolutions: NewlySolvedSlot[]): boolean | 'bad' {\r\n    const slot = this._slots[point.y][point.x];\r\n    if (!('form' in slot)) return false;\r\n\r\n    const solution = ResearchSlot_tryFinalize(slot);\r\n    if (solution === undefined) return false;\r\n    if (solution === 'bad') return 'bad';\r\n\r\n    if (solution !== 'new_info') {\r\n      this._slots[point.y][point.x] = solution;\r\n      newSolutions.push(Object.assign(point, solution));\r\n    }\r\n\r\n    return true;\r\n  }\r\n  \r\n  removeInvalidHypothesises(solved: NewlySolvedSlot[]): boolean | 'bad' {\r\n    let unstable = false;\r\n  \r\n    for (let y = 0; y != this.height; ++y) {\r\n      for (let x = 0; x != this.width; ++x) {\r\n        const slot = this._slots[y][x];\r\n  \r\n        if (!('form' in slot)) continue;\r\n  \r\n        this.getNeighbourSlotsOf({ x, y })\r\n        .forEach(({ other, dir }) => {\r\n          const r = considerOther(slot, other, dir);\r\n          unstable ||= r;\r\n        });\r\n  \r\n        let solveAtRes = this.solveAt({ x, y }, solved);\r\n        if (solveAtRes === 'bad') return 'bad';\r\n        unstable ||= solveAtRes;\r\n      }\r\n    }\r\n  \r\n    return unstable;\r\n  }\r\n\r\n  initialDeductions() {\r\n    const isAni = (slot: SolvationSlot) => {\r\n      if ('form' in slot) return slot.form === 'i';\r\n      const out = Slot_nbOfOutputs(slot);\r\n      return out === 1;\r\n    };\r\n\r\n    const moreThanTwois = (() => {\r\n      let cnt = 0;\r\n\r\n      for (let y = 0; y != this.height; ++y) {\r\n        for (let x = 0; x != this.width; ++x) {\r\n          const slot = this._slots[y][x];\r\n\r\n          if (isAni(slot)) {\r\n            if (cnt < 2) ++cnt;\r\n            else return true;\r\n          }\r\n        }\r\n      }\r\n\r\n      return false;\r\n    })();\r\n\r\n    \r\n    for (let y = 0; y != this.height; ++y) {\r\n      for (let x = 0; x != this.width; ++x) {\r\n        const slot = this._slots[y][x];\r\n        if (!('form' in slot)) continue;\r\n\r\n        this.getNeighboursOf({ x, y })\r\n        .forEach(({ other, dir }) => {\r\n          if (other === null) {\r\n            slot[dir] = DirStatus.No;\r\n          } else {\r\n            if (isAni(slot) && isAni(other)) {\r\n              slot[dir]                = moreThanTwois ? DirStatus.No : DirStatus.Yes;\r\n\r\n              if ('form' in other) {\r\n                other[Dir_opposite(dir)] = moreThanTwois ? DirStatus.No : DirStatus.Yes;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  explorePossibilitiesOfanI(): NewlySolvedSlot[] | null {\r\n    let listOfIs: Point2D[] = [];\r\n    const others: Point2D[] = [];\r\n\r\n    for (let y = 0; y !== this.height; ++y) {\r\n      for (let x = 0; x !== this.width; ++x) {\r\n        const slot = this._slots[y][x];\r\n        if ('form' in slot) {\r\n\r\n          if (slot.form === 'I')\r\n            listOfIs.push({ x, y });\r\n          else\r\n            others.push({ x, y });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (listOfIs.length === 0) {\r\n      listOfIs = others;\r\n      if (listOfIs.length === 0) return null;\r\n    }\r\n\r\n    const point = listOfIs[Math.floor(Math.random() * listOfIs.length)];\r\n\r\n    const current = this._slots[point.y][point.x] as ResearchSlot;\r\n\r\n    function compatible(slot: Slot<boolean>, current: ResearchSlot) {\r\n      for (const dir of Dirs) {\r\n        if (current[dir] === DirStatus.Yes && slot[dir] !== true ) return false;\r\n        if (current[dir] === DirStatus.No  && slot[dir] !== false) return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    for (const slot of\r\n      possibleSlots(current.form)\r\n      .filter(slot => compatible(slot, current))\r\n    ) {\r\n      const clone = this.clone();\r\n      clone._slots[point.y][point.x] = slot;\r\n\r\n      if (clone.getCompletitionState() === CompletitionStatus.Invalid) {\r\n        continue;\r\n      }\r\n\r\n      const solution = clone.trySolve();\r\n      if (solution !== null) {\r\n        return [Object.assign(point, slot), ...solution];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  trySolve(): NewlySolvedSlot[] | null {\r\n    let solution: NewlySolvedSlot[] = [];\r\n\r\n    this.initialDeductions();\r\n    while (true) {\r\n      const r = this.removeInvalidHypothesises(solution);\r\n\r\n      if (r === 'bad') return null;\r\n      if (r === false) break;\r\n    }\r\n\r\n    const gridState: CompletitionStatus = this.getCompletitionState();\r\n\r\n    if (gridState === CompletitionStatus.Invalid) {\r\n      return null;\r\n    } else if (gridState === CompletitionStatus.IncompleteValid) {\r\n      const hop = this.explorePossibilitiesOfanI();\r\n      if (!hop) return null;\r\n      return [...solution, ...hop];\r\n    } else {\r\n      return solution;\r\n    }\r\n  }\r\n\r\n  getCompletitionState(): CompletitionStatus {\r\n    // Search for a loop\r\n    let map = new Map<string, string>();\r\n    \r\n    for (let iRow = 0; iRow !== this.height; ++iRow) {\r\n      for (let iCol = 0; iCol !== this.width; ++iCol) {\r\n        map.set(Point2D_toString({ x: iCol, y: iRow }), Point2D_toString({ x: iCol, y: iRow }));\r\n      }\r\n    }\r\n\r\n    const rootOf = (point: Point2D) => {\r\n      let x = map.get(Point2D_toString(point))!;\r\n      while (x !== map.get(x)) {\r\n        x = map.get(x)!;\r\n      }\r\n\r\n      return x;\r\n    };\r\n\r\n    const rootOfStr = (point: string) => {\r\n      let x = map.get(point)!;\r\n      while (x !== map.get(x)) {\r\n        x = map.get(x)!;\r\n      }\r\n\r\n      return x;\r\n    };\r\n\r\n    // Ok\r\n\r\n    function compatible(lhs: boolean | DirStatus, rhs: boolean | DirStatus) {\r\n      if (lhs === true || lhs === DirStatus.Yes) {\r\n        return rhs === true || rhs === DirStatus.Yes || rhs === DirStatus.Maybe;\r\n      } else if (lhs === false || lhs === DirStatus.No) {\r\n        return rhs === false || rhs === DirStatus.No || rhs === DirStatus.Maybe;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    function connected(lhs: boolean | DirStatus, rhs: boolean | DirStatus) {\r\n      return (lhs === true || lhs === DirStatus.Yes || lhs === DirStatus.Maybe)\r\n        && (rhs === true || rhs === DirStatus.Yes || rhs === DirStatus.Maybe)\r\n    }\r\n\r\n    let isIncomplete = false;\r\n\r\n    for (let iRow = 0; iRow !== this.height; ++iRow) {\r\n      for (let iCol = 0; iCol !== this.width; ++iCol) {\r\n        const slot = this._slots[iRow][iCol];\r\n\r\n        if ('form' in slot) {\r\n          isIncomplete = true;\r\n        }\r\n\r\n        let invalid = false;\r\n        this.getNeighboursOf({ x: iCol, y: iRow })\r\n        .forEach(({other, point, dir}) => {\r\n          if (other === null) {\r\n            if (slot[dir] === true || slot[dir] === DirStatus.Yes) invalid = true;\r\n          } else {\r\n            if (!compatible(slot[dir], other[Dir_opposite(dir)])) invalid = true;\r\n\r\n            if (connected(slot[dir], other[Dir_opposite(dir)])) {\r\n              map.set(rootOf({ x: iCol, y: iRow }), rootOf(point!));\r\n            }\r\n          }\r\n        });\r\n\r\n        if (invalid) return CompletitionStatus.Invalid;\r\n      }\r\n    }\r\n\r\n    const group0 = rootOf({ x: 0, y: 0 });\r\n    for (const val of map.keys()) {\r\n      if (group0 !== rootOfStr(val)) return CompletitionStatus.Invalid;\r\n    }\r\n\r\n    return isIncomplete ? CompletitionStatus.IncompleteValid : CompletitionStatus.CompleteValid;\r\n  }\r\n}\r\n\r\nexport enum CompletitionStatus {\r\n  IncompleteValid,\r\n  CompleteValid,\r\n  Invalid\r\n}\r\n\r\nfunction possibleSlots(form: Form): Slot<boolean>[] {\r\n  if (form === 'i') {\r\n    return [\r\n      { north: true , east: false, south: false, west: false },\r\n      { north: false, east: true , south: false, west: false },\r\n      { north: false, east: false, south: true , west: false },\r\n      { north: false, east: false, south: false, west: true  },\r\n    ];\r\n  } else if (form === 'I') {\r\n    return [\r\n      { north: true , east: false, south: true , west: false },\r\n      { north: false, east: true , south: false, west: true  },\r\n    ];\r\n  } else if (form === 'L') {\r\n    return [\r\n      { north: true , east: true , south: false, west: false },\r\n      { north: false, east: true , south: true , west: false },\r\n      { north: false, east: false, south: true , west: true  },\r\n      { north: true , east: false, south: false, west: true  },\r\n    ];\r\n  } else {\r\n    return [\r\n      { north: true , east: true , south: true , west: false },\r\n      { north: false, east: true , south: true , west: true  },\r\n      { north: true , east: false, south: true , west: true  },\r\n      { north: true , east: true , south: false, west: true  },\r\n    ];\r\n  }\r\n}\r\n\r\nexport default function solve(grid: Grid<InstanciatedSlot>) {\r\n  const solved: NewlySolvedSlot[] = [];\r\n  const solvationGrid = SolvationGrid.fromIGrid(grid);\r\n\r\n  let r = solvationGrid.trySolve();\r\n  return r || [];\r\n\r\n  solvationGrid.initialDeductions();\r\n\r\n  let nbOfi = 0;\r\n\r\n  if (nbOfi > 2) {\r\n    // solvePathways(solvationGrid);\r\n  }\r\n\r\n  while (solvationGrid.removeInvalidHypothesises(solved));\r\n\r\n  return solved;\r\n}\r\n\r\nfunction considerOther(slot: ResearchSlot, other: SolvationSlot, myDir: Dir) {\r\n  const otherDir = Dir_opposite(myDir);\r\n\r\n  if (!('form' in other)) {\r\n    const expect = other[otherDir] ? DirStatus.Yes : DirStatus.No;\r\n    if (slot[myDir] === expect) return false;\r\n    slot[myDir] = expect;\r\n    return true;\r\n  }\r\n\r\n  if (other[otherDir] === DirStatus.Maybe) {\r\n    if (slot[myDir] !== DirStatus.Maybe) {\r\n      other[otherDir] = slot[myDir];\r\n      return true;\r\n    }\r\n  } else {\r\n    if (slot[myDir] === DirStatus.Maybe) {\r\n      slot[myDir] = other[otherDir];\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/*\r\nfunction isAni(slot: InstanciatedSlot | ResearchSlot | null) {\r\n  if (slot === null) return false;\r\n  if ('form' in slot) return slot.form === 'i';\r\n  return countNbOfOutput(slot) === 1;\r\n}\r\n\r\nfunction solvePathways(grid: ResearchGrid) {\r\n  for (let y = 0; y != grid.height; ++y) {\r\n    for (let x = 0; x != grid.width; ++x) {\r\n      const slot = grid.grid[y][x];\r\n\r\n      if ('form' in slot && slot.form === 'I') {\r\n        if (isAni(grid.get({ x, y }, 'east')) && isAni(grid.get({ x, y }, 'west'))) {\r\n          slot.east = DirStatus.No;\r\n          slot.west = DirStatus.No;\r\n        }\r\n\r\n        if (isAni(grid.get({ x, y }, 'south')) && isAni(grid.get({ x, y }, 'north'))) {\r\n          slot.south = DirStatus.No;\r\n          slot.north = DirStatus.No;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n*/","import { Dir, Dirs } from \"./dir\";\r\nimport { Point2D } from \"./grid-component\";\r\n\r\n/** A generic grid configuration */\r\nexport interface Grid_ {\r\n  /** The width of the grid (number of slots per line) */\r\n  get width(): number;\r\n  /** The height of the grid (number of slots per column) */\r\n  get height(): number;\r\n  /** If true, each opposite walls are connected */\r\n  get brokenWalls(): boolean;\r\n}\r\n\r\n/**\r\n * A grid. The only service provided by this class is moving on the grid, and\r\n * fetching the list of neighbours of a slot.\r\n */\r\nexport abstract class Grid<E> implements Grid_ {\r\n  abstract get width(): number;\r\n  abstract get height(): number;\r\n  abstract get brokenWalls(): boolean;\r\n\r\n  /**\r\n   * Return the slot at position point. Assumes that the given point is in bound\r\n   * i.e. 0 <= point.x < width and 0 <= point.y < height\r\n   * @param point The position of the slot.\r\n   */\r\n  abstract get(point: Point2D): E;\r\n\r\n  /**\r\n   * Moves from the given point to the given direction\r\n   * @param point The starting point\r\n   * @param dir The direction\r\n   * @returns The destination, or null if it would lead out of bound\r\n   */\r\n  #move(point: Point2D, dir: Dir): Point2D | null {\r\n    if (dir === 'north') {\r\n      if (point.y !== 0) {\r\n        return { x: point.x, y: point.y - 1 };\r\n      } else {\r\n        if (!this.brokenWalls) return null;\r\n        return { x: point.x, y: this.height - 1 };\r\n      }\r\n    } else if (dir === 'south') {\r\n      if (point.y !== this.height - 1) {\r\n        return { x: point.x, y: point.y + 1 };\r\n      } else {\r\n        if (!this.brokenWalls) return null;\r\n        return { x: point.x, y: 0 };\r\n      }\r\n    } else if (dir === 'west') {\r\n      if (point.x !== 0) {\r\n        return { x: point.x - 1, y: point.y };\r\n      } else {\r\n        if (!this.brokenWalls) return null;\r\n        return { x: this.width - 1, y: point.y };\r\n      }\r\n    } else if (dir === 'east') {\r\n      if (point.x !== this.width - 1) {\r\n        return { x: point.x + 1, y: point.y };\r\n      } else {\r\n        if (!this.brokenWalls) return null;\r\n        return { x: 0, y: point.y };\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the four neighbours of the point. If the neighbour is a wall,\r\n   * null is returned instead of a slot and an out-of-bound neighbour point.\r\n   * @param point The point\r\n   * @returns The list of neighbours, both slots and out-of-bound.\r\n   */\r\n  getNeighboursOf(point: Point2D): ({ other: E, point: Point2D, dir: Dir } | { other: null, point: null, dir: Dir })[] {\r\n    return Dirs.map(dir => {\r\n      const target = this.#move(point, dir);\r\n      if (target === null) {\r\n        return { other: null, point: null, dir: dir };\r\n      } else {\r\n        return { other: this.get(target), point: target, dir: dir };\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the list of slot neighbours of the given point\r\n   * @param point The point\r\n   * @returns The list of slot neighbours\r\n   */\r\n  getNeighbourSlotsOf(point: Point2D): { other: E, point: Point2D, dir: Dir }[] {\r\n    return this.getNeighboursOf(point)\r\n    .filter(c => c.other !== null) as { other: E, point: Point2D, dir: Dir }[];\r\n  }\r\n}\r\n","import { Dir, Dirs, Dir_opposite } from \"../base/dir\";\r\nimport { Point2D, Slot, Slot_nbOfOutputs } from \"../base/grid-component\";\r\nimport { InstanciatedSlot } from \"../gridapi\";\r\n\r\n// ============================================================================\r\n// == Partial knowledge on slots\r\n\r\n\r\n/** The form of a slot that has from 1 to 3 outputs */\r\nexport type Form = 'L' | 'I' | 'T' | 'i';\r\n\r\n/** Partial knowledge on outputs position */\r\nexport enum DirStatus { Maybe, Yes, No }\r\n\r\n/** Returns the opposite of the given DirStatus */\r\nexport function DirStatus_negate(status: DirStatus) {\r\n  if (status === DirStatus.Yes) return DirStatus.No;\r\n  if (status === DirStatus.No) return DirStatus.Yes;\r\n  return status;\r\n}\r\n\r\n/** A slot for which we have partial knowledge on outputs */\r\nexport type ResearchSlot = (Slot<DirStatus> & { form: Form; });\r\n\r\n/** A slot that is either resolved or on which we are looking for information */\r\nexport type SolvationSlot = ResearchSlot | Slot<boolean>;\r\n\r\n/** A slot for which we found the final position */\r\nexport type NewlySolvedSlot = Slot<boolean> & Point2D;\r\n\r\n// =====\r\n\r\n/**\r\n * Converts an instanciated slot, a concrete one in the grid, into a\r\n * SolvationSlot, one for which we are looking for the solution\r\n * @param slot The slot\r\n * @returns The solvation slot\r\n */\r\nexport function instanciatedToSolvationSlot(slot: InstanciatedSlot): SolvationSlot {\r\n  if (slot.blocked) {\r\n    return slot;\r\n  } else {\r\n    const numberOfDirections = Slot_nbOfOutputs(slot);\r\n    \r\n    if (numberOfDirections === 4 || numberOfDirections === 0) {\r\n      return slot;\r\n    } else {\r\n      return {\r\n        south: DirStatus.Maybe,\r\n        north: DirStatus.Maybe,\r\n        west: DirStatus.Maybe,\r\n        east: DirStatus.Maybe,\r\n        form: Slot_formOf(slot)\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Try to resolve the given research slot.\r\n * @returns A new slot if the finalization suceeded. Undefined if it couldn't.\r\n * 'new_info' if new information has been deduced.\r\n */\r\nexport function ResearchSlot_tryFinalize(slot: ResearchSlot): Slot<boolean> | undefined | 'new_info' | 'bad' {\r\n  const yes = ResearchSlot_count(slot, DirStatus.Yes);\r\n  const no = ResearchSlot_count(slot, DirStatus.No);\r\n\r\n  if (slot.form === 'T') {\r\n    if (yes === 4 || no >= 2) return 'bad';\r\n\r\n    if (yes === 3) return ResearchSlot_finalize(slot, DirStatus.No);\r\n    if (no === 1)  return ResearchSlot_finalize(slot, DirStatus.Yes);\r\n  } else if (slot.form === 'i') {\r\n    if (yes > 1 || no > 3) return 'bad';\r\n\r\n    if (yes === 1) return ResearchSlot_finalize(slot, DirStatus.No);\r\n    if (no === 3)  return ResearchSlot_finalize(slot, DirStatus.Yes);\r\n  } else if (slot.form === 'I') {\r\n    if (yes > 2 || no > 2) return 'bad';\r\n    for (const dir of Dirs) {\r\n      if (slot[dir] === DirStatus.Yes && slot[Dir_opposite(dir)] === DirStatus.No) return 'bad';\r\n    }\r\n\r\n    if (yes > 0 || no > 0) {\r\n      for (const dir of Dirs) {\r\n        if (slot[dir] !== DirStatus.Maybe) {\r\n          for (const d of Dirs) {\r\n            slot[d] = (d === dir || d === Dir_opposite(dir)) ? slot[dir] : DirStatus_negate(slot[dir]);\r\n          }\r\n\r\n          return ResearchSlot_finalize(slot, DirStatus.Yes);\r\n        }\r\n      }\r\n    }\r\n  } else if (slot.form === 'L') {\r\n    if (yes > 2 || no > 2) return 'bad';\r\n\r\n    for (const dir of Dirs) {\r\n      if (slot[dir] !== DirStatus.Maybe) {\r\n        if (slot[Dir_opposite(dir)] === slot[dir]) return 'bad';\r\n      }\r\n    }\r\n\r\n    const maybeBefore = ResearchSlot_count(slot, DirStatus.Maybe);\r\n\r\n    for (const dir of Dirs) {\r\n      if (slot[dir] !== DirStatus.Maybe) {\r\n        slot[Dir_opposite(dir)] = DirStatus_negate(slot[dir]);\r\n      }\r\n    }\r\n\r\n    const maybeAfter = ResearchSlot_count(slot, DirStatus.Maybe);\r\n\r\n    if (maybeAfter === 0) return ResearchSlot_finalize(slot, DirStatus.Yes);\r\n    if (maybeBefore !== maybeAfter) return 'new_info';\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction ResearchSlot_finalize(slot: ResearchSlot, maybeBecomes: DirStatus): Slot<boolean> {\r\n  const pass = (status: DirStatus) => (status === DirStatus.Maybe ? maybeBecomes : status) === DirStatus.Yes;\r\n\r\n  return {\r\n    north: pass(slot.north),\r\n    south: pass(slot.south),\r\n    east: pass(slot.east),\r\n    west: pass(slot.west)\r\n  };\r\n}\r\n\r\n/**\r\n * Clones the solvation slot if it is a research slot, returns the same object\r\n * if it is a solved slot.\r\n * @param slot The slot to clone\r\n */\r\nexport function SolvationSlot_clone(slot: SolvationSlot): SolvationSlot {\r\n  if ('form' in slot) {\r\n    return Object.assign({}, slot);\r\n  } else {\r\n    return slot;\r\n  }\r\n}\r\n\r\n/** Returns the number of outputs of the slot with the given status */\r\nexport function ResearchSlot_count(slot: ResearchSlot, status: DirStatus): 0 | 1 | 2 | 3 | 4 {\r\n  let cnt = 0;\r\n  if (slot.north === status) ++cnt;\r\n  if (slot.south === status) ++cnt;\r\n  if (slot.east === status) ++cnt;\r\n  if (slot.west === status) ++cnt;\r\n  return cnt as (0 | 1 | 2 | 3 | 4);\r\n}\r\n\r\n/**\r\n * Returns the slot of the slot. Throws if the slot has 0 or 4 outputs\r\n * @param slot The slot\r\n * @returns The form of the slot\r\n */\r\nexport function Slot_formOf(slot: Slot<boolean>): Form {\r\n  const numberOfDirections = Slot_nbOfOutputs(slot);\r\n\r\n  switch (numberOfDirections) {\r\n    case 1: return 'i';\r\n    case 3: return 'T';\r\n    case 2: return slot.south === slot.north ? 'I' : 'L';\r\n    default: throw Error(\"Fixed form slot\");\r\n  }\r\n}\r\n\r\n"],"names":["$cfaaa711720d035c$export$4f6ff81f13e75033","$24c03f35ab1abff0$export$95796b681493d318","$f43313d21d3fd8e2$var$LockParadigm","$f43313d21d3fd8e2$var$Playstyle","DirStatus","CompletitionStatus","LockParadigm","Playstyle","$461fef29bc99ab5c$export$e9e050f4e0d75ba8","$461fef29bc99ab5c$export$5b8cb9ace9acd75e","dir","Error","$4eca0d64d93ccd58$export$df9acae4caeab4be","self","y","x","$4eca0d64d93ccd58$export$a96947902a32785e","gridConf","copy","Object","assign","brokenWalls","height","width","$4eca0d64d93ccd58$export$9189e1451ddd7d48","slot","north","south","east","west","$4101c19663cb0e03$var$UnionFind","slotToGroup","constructor","Map","i","set","find","expected","realGroupId","get","union","slot1","slot2","$6a83c7ebd8a22ba4$export$ef2184bd89960b14","move","point","getNeighboursOf","map","target","other","getNeighbourSlotsOf","filter","c","$cfaaa711720d035c$export$235fd46f8105e076","status","Yes","No","$cfaaa711720d035c$var$ResearchSlot_finalize","maybeBecomes","pass","Maybe","$cfaaa711720d035c$export$231ac6a5472d9be8","cnt","$24c03f35ab1abff0$export$2bacf20dee8043b5","ruleset","_slots","theSlots","original","fromIGrid","grid","row","push","blocked","numberOfDirections","form","$cfaaa711720d035c$export$92abc197554724f7","clone","solveSomeSlots","newSolutions","unstable","col","notStable","solveAt","solution","yes","no","d","maybeBefore","maybeAfter","undefined","removeInvalidHypothesises","solved","forEach","r","$24c03f35ab1abff0$var$considerOther","myDir","otherDir","expect","solveAtRes","initialDeductions","isAni","out","moreThanTwois","explorePossibilitiesOfanI","listOfIs","others","length","Math","floor","random","current","$24c03f35ab1abff0$var$possibleSlots","compatible","getCompletitionState","Invalid","trySolve","gridState","IncompleteValid","hop","iRow","iCol","rootOf","rootOfStr","isIncomplete","invalid","lhs","rhs","group0","val","keys","CompleteValid","$f43313d21d3fd8e2$var$RealSlot","countPaths","isABar","draw","context","pipeStyle","lockParadigm","drawOnePath","fillStyle","fillRect","$f43313d21d3fd8e2$var$lockParadigmToStyle","lockedParadigm","LockedOk","LockedWithConflict","NotLocked","$f43313d21d3fd8e2$var$LINE_SIZE","rotate","temp","$f43313d21d3fd8e2$var$PlayerMaze","blackPipes","configuration","maze","$4101c19663cb0e03$var$initializeMaze","theMaze","theRow","to","$4101c19663cb0e03$var$buildOpenWalls","groups","h","v","$4101c19663cb0e03$var$initWalls","notBroken","numberOfDiffGroups","res","openedWalls","breakable","breakHorizontal","wallsToBreak","randomIndex","splice","g1","g2","origin","neighbour","config","invertColorDisplay","canvas","getPipeColor","checkWin","mapping","$f43313d21d3fd8e2$var$computeNetworks","posToGroup","nextGroupId","pos1d","has","exploreNetworkOf","result","groupId","entries","ctx","getContext","extra","$f43313d21d3fd8e2$var$SLOT_SIZE","color","lp","_lockParadigmOf","that","drawBrokenWall","drawX","drawY","globalAlpha","fitsWithNearbyBlocked","memberConsumer","explored","Set","add","toExplore","explore","hisDir","dx","dy","code","next","nb","solve","solvationGrid","shift","direction","where","loop","value","round","newGrid","$f43313d21d3fd8e2$var$DEFAULT_SETTINGS","broken","window","onload","document","getElementById","toString","checked","setupNewGrid","trueMaze","parseInt","$f43313d21d3fd8e2$var$setCanvasSize","style","getClickedSlot","event","clientX","getBoundingClientRect","clientY","slotX","slotY","type","directions","onclick","addEventListener","clickedOn","$f43313d21d3fd8e2$var$rotateSlot","slotPoint","playstyle","$f43313d21d3fd8e2$var$getCurrentPlaystyle","select","AutoLock","Restrained","Free","goodFits","nbOfGoodFits","preventDefault","e","key"],"version":3,"file":"index.d072d556.js.map"}